[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Willkommen!",
    "section": "",
    "text": "Dies ist die Seite zu meiner Data Science-AG, die ich von Januar bis Juni 2024 halten möchte. Auf dieser Seite werden nach und nach R-Skripte entstehen, die jeweils in den AG-Stunden erstellt werden."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#anfang",
    "href": "index.html#anfang",
    "title": "Start in R",
    "section": "",
    "text": "Wir starten einfach.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#mitte",
    "href": "index.html#mitte",
    "title": "Start in R",
    "section": "Mitte",
    "text": "Mitte\n\nCode\nNoch etwas Code.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\n\nErklärung\nHier könnte Ihre Erklärung stehen."
  },
  {
    "objectID": "index.html#ende",
    "href": "index.html#ende",
    "title": "Start in R",
    "section": "Ende",
    "text": "Ende\nDas ist das Ende."
  },
  {
    "objectID": "01-einfuehrung.html",
    "href": "01-einfuehrung.html",
    "title": "Installation",
    "section": "",
    "text": "Was nötig ist, um mit R arbeiten zu können, hängt davon ab, welches Betriebssystem auf eurem Gerät installiert ist."
  },
  {
    "objectID": "index.html#ablauf",
    "href": "index.html#ablauf",
    "title": "Willkommen!",
    "section": "Ablauf",
    "text": "Ablauf\n\nUnter “Einführung in R” finden sich Anleitungen, die die Einrichtung von R erklären und den Aufbau der Software “RStudio” erläutern. Zudem behandeln wir dort die ersten Schritte im Programmieren mit R.\nDas erste Treffen findet voraussichtlich am 12. Januar 2024 im GaW statt. Der Raum wird noch bekannt gegeben.\nMathematikkenntnisse bis zur EF sind erforderlich. Programmierkenntnisse sind nicht vonnöten."
  },
  {
    "objectID": "01-einfuehrung.html#installation",
    "href": "01-einfuehrung.html#installation",
    "title": "Einführung in R",
    "section": "",
    "text": "Was nötig ist, um mit R arbeiten zu können, hängt davon ab, welches Betriebssystem auf eurem Gerät installiert ist.\n\n\nAuf Windows und MacOS müssen wir zwei Programme installieren: zum einen die R-Distribution (das heißt, das Paket, mit dem man R-Code ausführen kann), zum anderen eine Entwicklungsumgebung, in der wir unseren R-Code schreiben können und die uns zahlreiche Hilfsmittel zum Schreiben unseres Codes und zum Anzeigen unserer Ergebnisse bietet.\nIn den vergangenen Jahren habe ich einige verschiedene ausprobiert, aber ich bin am Ende immer zu der bekanntesten Software für R zurückgekehrt, nämlich RStudio. RStudio ist eine von der Firma Posit entwickelte grafische Oberfläche, mit der ihr euren R-Code strukturiert schreiben und die Ergebnisse eurer Analyse ansprechend aufbereiten könnt. Natürlich könnt ihr auch andere Programme ausprobieren und benutzen, aber die weiteren Erklärungen sind auf RStudio ausgerichtet.\n\nR-Distribution\nR ist eine frei verfügbare Software und kann somit von jedem kostenlos heruntergeladen werden.\nIhr könnt sie installieren, indem ihr die Seite cran.r-project.org aufruft und dort auf den Link Download R for MacOS bzw. Download R for Windows klickt. Wenn ihr ein MacBook habt, wählt ihr auf dieser Seite die passende Version für euer Gerät aus. Bei Windows klicken wir auf base und dann auf den Downloadlink ganz oben.\nIhr folgt dann den Installationsanweisungen, dabei könnt ihr alles bei den Standardeinstellungen belassen.\nEntwicklungsumgebung\nDamit wir die R-Distribution sinnvoll nutzen können, benötigen wir eine Entwicklungsumgebung, in unserem Fall RStudio.\nUm RStudio zu installieren, geht auf die Seite posit.co/download/rstudio-desktop. Dort seht ihr den Punkt 2: Install RStudio. Es sollte bereits das richtige Betriebssystem vorgewählt sein, ansonsten finden sich darunter noch weitere Installer. Ladet nun durch Klick auf den Button Download RStudio for … das Installationsprogramm herunter und folgt den Installationsanweisungen.\n\nNun sollten sowohl R als auch RStudio auf eurem Gerät installiert sein."
  },
  {
    "objectID": "01-einfuehrung.html#ipads-and-android-tablets",
    "href": "01-einfuehrung.html#ipads-and-android-tablets",
    "title": "Einführung in R",
    "section": "iPads and Android tablets",
    "text": "iPads and Android tablets\nUnder construction."
  },
  {
    "objectID": "01-einfuehrung.html#ipads-und-android-tablets",
    "href": "01-einfuehrung.html#ipads-und-android-tablets",
    "title": "Installation",
    "section": "iPads und Android-Tablets",
    "text": "iPads und Android-Tablets\nAuch auf einem iPad oder einem Android-Tablet kann man mit R programmieren, auch wenn das ohne Tastatur und Maus wahrscheinlich schwierig ist. Sollte es so sein, dass ihr keinen Zugang zu einem Laptop habt, ist dies jedoch eine mögliche Lösung:\nWir installieren kein Programm auf unserem Gerät. Stattdessen erstellen wir ein Benutzerkonto bei Posit, dem Anbieter von RStudio. Auf diese Weise können wir, wenn auch nur mit beschränkter Rechenzeit, in unserem Browser programmieren. Hierzu geht ihr auf die Seite von Posit, posit.cloud, und klickt dort auf Get started. Wählt den kostenlosen Plan (Cloud Free) aus und registriert euch dann unter Sign up. Wenn das geklappt hat, solltet ihr bereit sein, um in R zu programmieren."
  },
  {
    "objectID": "01-einfuehrung.html#linux",
    "href": "01-einfuehrung.html#linux",
    "title": "Installation",
    "section": "Linux",
    "text": "Linux\nSolltet ihr eine Linux-Distribution auf eurem Laptop installiert haben, dann findet ihr auf YouTube sowie mit einer kurzen Internetrecherche zahlreiche Anleitungen, wie ihr R auf eurer Plattform installieren könnt. Ich gehe nicht näher auf diesen Fall ein, da man je nach Distribution unterschiedlich verfahren muss und ich dem geneigten Linux-Nutzer unterstelle, selbst in der Lage zu sein, die Installation durchzuführen."
  },
  {
    "objectID": "01-einfuehrung.html#windows-und-macos",
    "href": "01-einfuehrung.html#windows-und-macos",
    "title": "Installation",
    "section": "Windows und MacOS",
    "text": "Windows und MacOS\nAuf Windows und MacOS müssen wir zwei Programme installieren: zum einen die R-Distribution (das heißt, das Paket, mit dem man R-Code ausführen kann), zum anderen eine Entwicklungsumgebung, in der wir unseren R-Code schreiben können und die uns zahlreiche Hilfsmittel zum Schreiben unseres Codes und zum Anzeigen unserer Ergebnisse bietet.\nIn den vergangenen Jahren habe ich einige verschiedene ausprobiert, aber ich bin am Ende immer zu der bekanntesten Software für R zurückgekehrt, nämlich RStudio. RStudio ist eine von der Firma Posit entwickelte grafische Oberfläche, mit der ihr euren R-Code strukturiert schreiben und die Ergebnisse eurer Analyse ansprechend aufbereiten könnt. Natürlich könnt ihr auch andere Programme ausprobieren und benutzen, aber die weiteren Erklärungen sind auf RStudio ausgerichtet.\n\nR-Distribution\nR ist eine frei verfügbare Software und kann somit von jedem kostenlos heruntergeladen werden.\nIhr könnt sie installieren, indem ihr die Seite cran.r-project.org aufruft und dort auf den Link Download R for MacOS bzw. Download R for Windows klickt. Wenn ihr ein MacBook habt, wählt ihr auf dieser Seite die passende Version für euer Gerät aus. Bei Windows klicken wir auf base und dann auf den Downloadlink ganz oben.\nIhr folgt dann den Installationsanweisungen, dabei könnt ihr alles bei den Standardeinstellungen belassen.\nEntwicklungsumgebung\nDamit wir die R-Distribution sinnvoll nutzen können, benötigen wir eine Entwicklungsumgebung, in unserem Fall RStudio.\nUm RStudio zu installieren, geht auf die Seite posit.co/download/rstudio-desktop. Dort seht ihr den Punkt 2: Install RStudio. Es sollte bereits das richtige Betriebssystem vorgewählt sein, ansonsten finden sich darunter noch weitere Installer. Ladet nun durch Klick auf den Button Download RStudio for … das Installationsprogramm herunter und folgt den Installationsanweisungen.\n\nNun sollten sowohl R als auch RStudio auf eurem Gerät installiert sein."
  },
  {
    "objectID": "01-installation.html",
    "href": "01-installation.html",
    "title": "1.1 Installation",
    "section": "",
    "text": "Was nötig ist, um mit R arbeiten zu können, hängt davon ab, welches Betriebssystem auf eurem Gerät installiert ist."
  },
  {
    "objectID": "01-installation.html#windows-und-macos",
    "href": "01-installation.html#windows-und-macos",
    "title": "1.1 Installation",
    "section": "Windows und MacOS",
    "text": "Windows und MacOS\nAuf Windows und MacOS müssen wir zwei Programme installieren: zum einen die R-Distribution (das heißt, das Paket, mit dem man R-Code ausführen kann), zum anderen eine Entwicklungsumgebung, in der wir unseren R-Code schreiben können und die uns zahlreiche Hilfsmittel zum Schreiben unseres Codes und zum Anzeigen unserer Ergebnisse bietet.\nIn den vergangenen Jahren habe ich einige verschiedene ausprobiert, aber ich bin am Ende immer zu der bekanntesten Software für R zurückgekehrt, nämlich RStudio. RStudio ist eine von der Firma Posit entwickelte grafische Oberfläche, mit der ihr euren R-Code strukturiert schreiben und die Ergebnisse eurer Analyse ansprechend aufbereiten könnt. Natürlich könnt ihr auch andere Programme ausprobieren und benutzen, aber die weiteren Erklärungen sind auf RStudio ausgerichtet.\n\nR-Distribution\nR ist eine frei verfügbare Software und kann somit von jedem kostenlos heruntergeladen werden.\nIhr könnt sie installieren, indem ihr die Seite cran.r-project.org aufruft und dort auf den Link Download R for MacOS bzw. Download R for Windows klickt. Wenn ihr ein MacBook habt, wählt ihr auf dieser Seite die passende Version für euer Gerät aus. Bei Windows klicken wir auf base und dann auf den Downloadlink ganz oben.\nFolgt dann den Installationsanweisungen, dabei könnt ihr alles bei den Standardeinstellungen belassen.\nEntwicklungsumgebung\nDamit wir die R-Distribution sinnvoll nutzen können, benötigen wir eine Entwicklungsumgebung, in unserem Fall RStudio.\nUm RStudio zu installieren, geht auf die Seite posit.co/download/rstudio-desktop. Dort seht ihr den Punkt 2: Install RStudio. Es sollte bereits das richtige Betriebssystem vorgewählt sein, ansonsten finden sich darunter noch weitere Installer. Ladet nun durch Klick auf den Button Download RStudio for … das Installationsprogramm herunter und folgt den Installationsanweisungen.\n\nNun sollten sowohl R als auch RStudio auf eurem Gerät installiert sein."
  },
  {
    "objectID": "01-installation.html#ipads-und-android-tablets",
    "href": "01-installation.html#ipads-und-android-tablets",
    "title": "1.1 Installation",
    "section": "iPads und Android-Tablets",
    "text": "iPads und Android-Tablets\nAuch auf einem iPad oder einem Android-Tablet kann man mit R programmieren, auch wenn das ohne Tastatur und Maus wahrscheinlich schwierig ist. Sollte es so sein, dass ihr keinen Zugang zu einem Laptop habt, ist dies jedoch eine mögliche Lösung:\nWir installieren kein Programm auf unserem Gerät. Stattdessen erstellen wir ein Benutzerkonto bei Posit, dem Anbieter von RStudio. Auf diese Weise können wir, wenn auch nur mit beschränkter Rechenzeit, in unserem Browser programmieren. Hierzu geht ihr auf die Seite von Posit, posit.cloud, und klickt dort auf Get started. Wählt den kostenlosen Plan (Cloud Free) aus und registriert euch dann unter Sign up. Wenn das geklappt hat, solltet ihr bereit sein, um in R zu programmieren."
  },
  {
    "objectID": "01-installation.html#linux",
    "href": "01-installation.html#linux",
    "title": "1.1 Installation",
    "section": "Linux",
    "text": "Linux\nSolltet ihr eine Linux-Distribution auf eurem Laptop installiert haben, dann findet ihr auf YouTube sowie mit einer kurzen Internetrecherche zahlreiche Anleitungen, wie ihr R auf eurer Plattform installieren könnt. Ich gehe nicht näher auf diesen Fall ein, da man je nach Distribution unterschiedlich verfahren muss und ich dem geneigten Linux-Nutzer unterstelle, selbst in der Lage zu sein, die Installation durchzuführen."
  },
  {
    "objectID": "02-erste-schritte.html#skripte-erstellen",
    "href": "02-erste-schritte.html#skripte-erstellen",
    "title": "1.2 Erste Schritte in RStudio",
    "section": "Skripte erstellen",
    "text": "Skripte erstellen"
  },
  {
    "objectID": "02-erste-schritte.html#pakete",
    "href": "02-erste-schritte.html#pakete",
    "title": "1.2 Erste Schritte in RStudio",
    "section": "Pakete",
    "text": "Pakete\nUnder construction."
  },
  {
    "objectID": "02-erste-schritte.html#packages",
    "href": "02-erste-schritte.html#packages",
    "title": "1.2 Erste Schritte in RStudio",
    "section": "Packages",
    "text": "Packages\n\n\nDer Code, der im Video verwendet wurde:\n\nlibrary(ggplot2)\n\nmtcars\n\nggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  geom_smooth(method = lm)"
  },
  {
    "objectID": "02-erste-schritte.html",
    "href": "02-erste-schritte.html",
    "title": "1.2 Erste Schritte in RStudio",
    "section": "",
    "text": "Auf dieser Seite findet ihr drei Videos, die euch mit den Grundfunktionen von R und RStudio vertraut machen sollen."
  },
  {
    "objectID": "02-erste-schritte.html#hauptfenster-und-konsole",
    "href": "02-erste-schritte.html#hauptfenster-und-konsole",
    "title": "1.2 Erste Schritte in RStudio",
    "section": "Hauptfenster und Konsole",
    "text": "Hauptfenster und Konsole"
  },
  {
    "objectID": "index.html#zielsetzung",
    "href": "index.html#zielsetzung",
    "title": "Willkommen!",
    "section": "Zielsetzung",
    "text": "Zielsetzung\nDas Ziel dieser AG ist es, mithilfe der statistischen Programmiersprache R interessante Fragestellungen zu beantworten. Dabei sollen die Schülerinnen und Schüler einerseits lernen, in R zu programmieren und diese Fähigkeit auf reale Datensätze anwenden, andererseits Methoden und Ergebnisse kritisch zu hinterfragen und somit zu neuen, datenbasierten Erkenntnissen gelangen."
  },
  {
    "objectID": "praesentation_ag.html",
    "href": "praesentation_ag.html",
    "title": "Data Science-AG",
    "section": "",
    "text": "Data Science-AG\n\n\nWas machen wir?\n\nDatenanalyse\nDazu brauchen wir zwei Dinge:\n\nDaten\nEine Programmiersprache (R)\n\n\n\n\n\n\nWelche Daten?\n\nWetterdaten vom DWD\nDatensätze von Kaggle\n\nTestergebnisse von Schulen (USA)\nEuropean Social Survey (EU)\nImmobilieninserate (D)\n\n\n\n\n\nWelche Daten?\n\nDatensätze von Kaggle\n\nPew Research Center-Befragungen (USA)\nCoronadaten (D/EU)\n\n\n\n\nDaten zu ESC-Teilnehmersongs (GitHub)\nund viele mehr\n\n\n\nWieso R?\n\nStatistische Programmiersprache\nzahlreiche Packages\nim akademischen Bereich häufig genutzt\nOpen-Source\nHandhabe von Daten (“Data Wrangling”) deutlich einfacher als in Python\n\n\n\nWas jetzt?\n\nWebsite für die AG ist bereits verfügbar\nPlan: Start nach den Weihnachtsferien\nEigene Projekte am Ende des Schuljahres"
  },
  {
    "objectID": "03-datenstrukturen.html",
    "href": "03-datenstrukturen.html",
    "title": "2.1 Datentypen und Datenstrukturen",
    "section": "",
    "text": "Nachdem wir uns mit RStudio vertraut gemacht haben, kommen wir nun zur ersten wirklichen inhaltlichen Auseinandersetzung mit R, nämlich mit Datentypen und Datenstrukturen. Wir wollen verstehen, welche es gibt und wie diese funktionieren, um sie in unserer Datenanalyse später benutzen zu können."
  },
  {
    "objectID": "03-datenstrukturen.html#datentypen",
    "href": "03-datenstrukturen.html#datentypen",
    "title": "2.1 Datentypen und Datenstrukturen",
    "section": "Datentypen",
    "text": "Datentypen\nNumeric\nDer Datentyp numeric beinhaltet alle reellen Zahlen. Zusätzlich werden alle ganzen Zahlen standardmäßig als numeric klassifiziert.\nDies können wir im folgenden Beispiel sehen:\n\nganzzahl &lt;- 1\ndezimalzahl &lt;- 1.0\n\nclass(ganzzahl)\n\n[1] \"numeric\"\n\nclass(dezimalzahl)\n\n[1] \"numeric\"\n\nganzzahl == dezimalzahl\n\n[1] TRUE\n\n\nCharacter\nDer Datentyp character beschreibt Wörter, Sätze; alles, was man mit Zahlen und Buchstaben zusammenfügen kann.\n\ntext &lt;- \"Wir lernen R.\"\n\nclass(text)\n\n[1] \"character\"\n\ntext_kopie &lt;- \"Wir lernen R.\"\n\ntext == text_kopie\n\n[1] TRUE\n\n\nLogical\nDer Datentyp logical beinhaltet die Werte TRUE und FALSE (wahr und falsch). Sie können auch mit T und F abgekürzt werden. Man kann mit TRUE und FALSE auch rechnen, TRUE hat hierbei den Wert 1, FALSE den Wert 0.\n\nwahr &lt;- TRUE\nfalsch &lt;- FALSE\n\nwahr_kurz &lt;- T\nfalsch_kurz &lt;- F\n\nwahr == wahr_kurz\n\n[1] TRUE\n\nfalsch == falsch_kurz\n\n[1] TRUE\n\nwahr + falsch\n\n[1] 1\n\n\nWeniger wichtige Datentypen\nInteger\nDer Datentyp integer enthält alle ganzen Zahlen. Integer werden mit einem L hinter der Zahl gekennzeichnet.\n\nganzzahl &lt;- 1L\n\nclass(ganzzahl)\n\n[1] \"integer\"\n\nandere_ganzzahl &lt;- 2L\n\nsumme &lt;- ganzzahl + andere_ganzzahl\n\nclass(summe)\n\n[1] \"integer\"\n\n# In der Konsole wird das 'L' nicht mit ausgegeben!\nganzzahl\n\n[1] 1\n\n\nComplex\nDieser Datentyp beinhaltet alle komplexen Zahlen.\n\nkomplexe_zahl &lt;- 1i + 1\n\nclass(komplexe_zahl)\n\n[1] \"complex\"\n\nandere_komplexe_zahl &lt;- 9i + 3\n\nkomplexe_zahl + andere_komplexe_zahl\n\n[1] 4+10i"
  },
  {
    "objectID": "03-datenstrukturen.html#datenstrukturen",
    "href": "03-datenstrukturen.html#datenstrukturen",
    "title": "2.1 Datentypen und Datenstrukturen",
    "section": "Datenstrukturen",
    "text": "Datenstrukturen\nWir können mit Variablen aus den oben angegebenen Datentypen sehr gut einfache Rechnungen und Vergleiche durchführen. Um aber effizient zu arbeiten und unsere Daten zu verwalten, braucht es Strukturen, in denen wir Variablen speichern und modifizieren können.\nVektor\nDie wohl wichtigste Datenstruktur in R ist der Vektor. Vektoren sind Ansammlungen von Variablen eines bestimmten Datentyps. Ein Beispiel ist der Vektor \\(\\vec{x}=\\begin{pmatrix}1 \\\\ 2 \\\\ 3\\end{pmatrix}\\), der die Zahlen 1, 2, und 3 enthält.\nWir erstellen oder initialisieren einen Vektor mit der c()-Funktion:\n\n# Vektor initialisieren\nx &lt;- c(1, 2, 3)\n\n# Vektor ausgeben\nx\n\n[1] 1 2 3\n\n\nWenn wir auf Elemente im Vektor zugreifen wollen, dann machen wir das durch eckige Klammern hinter dem Namen des Vektors:\n\n# R beginnt bei der Zählung mit der 1.\nx[1]        # 1. Element\n\n[1] 1\n\nx[-1]       # alle außer dem 1. Element\n\n[1] 2 3\n\nx[1:2]      # alle Elemente vom 1. bis zum 2.\n\n[1] 1 2\n\nx[c(1, 3)]  # alle Elemente, deren Index im Vektor (1,3) enthalten ist\n\n[1] 1 3\n\n\nWir können mit Vektoren ganz normal rechnen (Zeile für Zeile):\n\nx * 3\n\n[1] 3 6 9\n\n# Neuer Vektor\ny &lt;- c(3, 4, 5)\n\n# Zeilenweise Addition/Subtraktion\nx + y\n\n[1] 4 6 8\n\nx - y\n\n[1] -2 -2 -2\n\n# Für alle, die schon Vektoren behandelt haben:\n# Betrag eines Vektors\n# type = \"2\" steht für die sogenannte \"2-Norm\" (die euklidische Norm)\nnorm(x, type = \"2\")\n\n[1] 3.741657\n\n\nWir können verschiedene “Maße” des Vektors nehmen:\n\nlength(x)   # Dimension oder \"Länge\" des Vektors\n\n[1] 3\n\nmean(x)     # Mittelwert des Vektors\n\n[1] 2\n\nsum(x)      # Summe der Einträge des Vektors\n\n[1] 6\n\n\nAufgabe 1\nGib den kleinsten und den größten Eintrag sowie den Median von x an!\n\nLösungmin(x)\nmax(x)\nmedian(x)\n\n\nDataframe und Tibble\nFür diesen Teil und auch darüber hinaus benötigen wir die tidyverse-Library. Es bietet zahlreiche nützliche Features, die uns beim Codeschreiben viel Arbeit abnehmen und unseren Code besser lesbar machen werden.\nWenn ihr diese Library noch nicht installiert habt, dann geht das mit dem folgenden Befehl in eurer Konsole:\n\ninstall.packages(\"tidyverse\")\n\nWir laden nun die tidyverse-Library in unseren Arbeitsbereich, indem wir folgenden Code benutzen:\n\nlibrary(tidyverse)\n\nDataframes bzw. Tibbles sind ähnlich wie Tabellen: Sie speichern geordnet Daten. Dabei sind in den Zeilen die verschiedenen Einträge angeordnet, und in den Spalten finden sich Variablen für jeden dieser Einträge.\nWir rufen nun das mtcars-Datenset auf, eines der bekanntesten Datensets in R, auf das auch ohne weitere Pakete direkt zugegriffen werden kann. Das mtcars-Datenset enthält Daten zu einigen (älteren) Autos. Die Beschreibung dieses Datensets finden wir, indem wir ?mtcars in die Konsole eingeben.\n\n# Um nur die obersten Einträge eines Datensets auszugeben,\n# benutzen wir die head()-Funktion\nhead(mtcars)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nWir erhalten eine Übersicht über die ersten Autos und ihre Spezifikationen. Doch wie wir im Einführungskapitel gesehen haben, ist das nicht das Einzige, was wir mit Dataframes oder Tibbles machen können.\nWir wollen nun alle Autos mit mehr als 30 Meilen pro Gallone Benzin ausgeben. Hierbei können wir mit dem Dollarzeichen auf einzelne Spalten zugreifen, und ähnlich wie bei Vektoren benutzen wir eckige Klammern, um auf einzelne Elemente zuzugreifen. Die Schreibweise hierbei ist wie folgt: Datenset[Bedingung für Zeilen, Bedingung für Spalten]. Da wir hier die Zeilen (Autos) mit mehr als 30 Meilen pro Gallone ausgeben wollen, füllen wir diese Bedingung in die Bedingung für Zeilen ein und erhalten das gewünschte Ergebnis.\n\nmtcars[mtcars$mpg &gt; 30, ]\n\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1\nLotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2\n\n\nDas ist aber bei mehreren Bedingungen, oder wenn wir diesen Filter in eine Folge aus Operationen einbinden wollen, ziemlich schwer zu schreiben und vor allem zu lesen. Deswegen überführen wir dieses Datenset mit der as_tibble()-Funktion in einen Tibble, auf dem wir viel einfacher filtern und später auch Daten entfernen, zusammenfügen usw. können. Für diese Funktion muss nun das tidyverse-Paket installiert sein (s.o.).\n\nmtcars_tibble &lt;- as_tibble(mtcars)\n\nSchauen wir uns diesen Tibble mal an:\n\nmtcars_tibble\n\n# A tibble: 32 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# ℹ 22 more rows\n\n\nKomisch, die Autonamen sind weg! Das liegt daran, dass Tibbles etwas anders funktionieren als Dataframes. Dataframes haben benannte Zeilen, während Tibbles an sich diese Information nicht speichern. Wir müssen daher Folgendes machen:\n\nmtcars_tibble &lt;- as_tibble(rownames_to_column(mtcars))\n\nmtcars_tibble\n\n# A tibble: 32 × 12\n   rowname       mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 Mazda RX4    21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2 Mazda RX4 …  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3 Datsun 710   22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4 Hornet 4 D…  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5 Hornet Spo…  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6 Valiant      18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7 Duster 360   14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8 Merc 240D    24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9 Merc 230     22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10 Merc 280     19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# ℹ 22 more rows\n\n\nViel besser. Mit diesem Tibble können wir nun viel einfacher filtern, nämlich mit der filter()-Funktion:\n\nfilter(mtcars_tibble, mpg &gt; 30)\n\n# A tibble: 4 × 12\n  rowname        mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Fiat 128      32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1\n2 Honda Civic   30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2\n3 Toyota Coro…  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1\n4 Lotus Europa  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2\n\n\nOben haben wir schon gesehen, dass wir zum Umformen des Dataframes in einen Tibble mehrere Schritte ineinander bauen müssen. Wollen wir nun noch den ursprünglichen Dataframe vor der Umformung verändern, kann das ziemlich schnell unübersichtlich werden:\n\n# Wir wollen z.B. in einem Schritt den Dataframe in einen Tibble umwandeln und dann filtern:\nfilter(as_tibble(rownames_to_column(mtcars)), mpg &gt; 30)\n\n# A tibble: 4 × 12\n  rowname        mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Fiat 128      32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1\n2 Honda Civic   30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2\n3 Toyota Coro…  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1\n4 Lotus Europa  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2\n\n# Unübersichtlich und fehleranfällig!\n\nStattdessen führen wir den sogenannten Pipe-Operator (geschrieben %&gt;%) als neue Schreibweise ein. Man kann sich seine Funktion so vorstellen, dass er alles, was auf der linken Seite von ihm steht, nimmt und dem, was auf der rechten Seite steht, übergibt. Wir wollen den vorherigen Codeblock einfacher schreiben:\n\n# Lesen von links nach rechts:\nmtcars %&gt;%                     # Wir nehmen das mtcars-Datenset...\n  rownames_to_column() %&gt;%     # und lagern die Namen in eine eigene Spalte aus...\n  as_tibble() %&gt;%              # und konvertieren das in einen Tibble...\n  filter(mpg &gt; 30)             # und filtern nach Autos, die mehr als 30 MPG haben.\n\n# A tibble: 4 × 12\n  rowname        mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Fiat 128      32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1\n2 Honda Civic   30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2\n3 Toyota Coro…  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1\n4 Lotus Europa  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2\n\n\nViel einfacher lesbar, oder? Wir werden diese Datenstruktur sehr häufig nutzen, eben weil wir diese Funktionen anwenden können.\nAufgabe 2\nWähle alle außer den ersten 15 Autos aus (?slice in die Konsole einzugeben könnte hilfreich sein, schaue dort nach einem Weg, Zeilen auszuschließen) und filtere dann nach den Autos mit mindestens 6 Zylindern. Sortiere dann die Autos nach Meilen pro Gallone (absteigend; ?arrange könnte hilfreich sein, schaue dort unter den Beispielen nach einem Weg, absteigend zu sortieren). Zeige nur die Namen der Autos, die Meilen pro Gallone, die Zylinder und die PS an (?select könnte hilfreich sein).\n\nLösungmtcars_tibble %&gt;%                  # Tibble auswählen\n  slice(-(1:15)) %&gt;%               # Alle außer den ersten 15 Zeilen auswählen\n  filter(cyl &gt;= 6) %&gt;%             # Alle Autos mit mindestens 6 Zylindern\n  arrange(desc(mpg)) %&gt;%           # Autos nach Meilen pro Gallone sortieren\n  select(rowname, mpg, cyl, hp)    # Nur Name, MPG, Zylinder, PS anzeigen\n\n\nAufgabe 3\nNew York gehört mit seinen Flughäfen zu den weltweit bekanntesten Verkehrsdrehkreuzen. Es ist so bekannt, dass es in R eine eigene Library für die Aufzeichnung aller abgehenden Flüge im Jahr 2013 gibt.\nInstalliere für diese Aufgabe die nycflights13-Library und lade sie in den Arbeitsbereich. Uns interessiert vor allem der flights-Tibble.\n\nWelche Flüge sind verfrüht abgehoben?\nWelche Flüge sind verspätet abgehoben und haben die Verspätung aufgeholt?\nFüge eine neue Variable short_flight zum Tibble hinzu, die den Wert 1 annimmt, wenn der Flug weniger als 2 Stunden Flugzeit hat, und ansonsten 0 ist (Hinweis: ?mutate könnte hilfreich sein).\nWelcher Anteil an verspätet abgehobenen Flügen, die die Verspätung aufgeholt haben, hatten weniger als zwei Stunden Flugzeit?\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nZu 3.: Nutze nach dem Filtern mutate(... = if_else(...)), um für jeden Flug die Variable short_flight zu erstellen.\nZu 4.: Verwende die Funktionen summarise(), sum() und n(), um den Anteil zu errechnen.\n\n\n\n\nLösunglibrary(nycflights13)\n\n# 1\nflights %&gt;% \n  filter(dep_delay &lt; 0)\n\n# 2\nflights %&gt;% \n  filter(dep_delay &gt; 0 & arr_delay &lt;= 0)\n\n# 3\nflights %&gt;% \n  filter(dep_delay &gt; 0 & arr_delay &lt;= 0) %&gt;% \n  mutate(short_flight = if_else(air_time &lt; 120, 1, 0)) \n\n# 4\nflights %&gt;% \n  filter(dep_delay &gt; 0 & arr_delay &lt;= 0) %&gt;% \n  mutate(short_flight = if_else(air_time &lt; 120, 1, 0)) %&gt;% \n  summarise(share_short = sum(short_flight)/n())\n\n\nListe\nInfo: Dieses Kapitel folgt grob den Inhalten aus Kapitel 9 in “Beginning Computer Science with R” von Homer White.\nDie Datenstrukturen, die wir uns bisher angeschaut haben, waren atomisch, das heißt, sie können pro Einheit (bspw. Spalte) nur eine Art Datentyp beinhalten. Nun gehen wir über zu den Listen, die Objekte aller Arten beinhalten können. Zahlen, Wörter, andere Listen, alles ist möglich.\nWir beginnen die Erkundung, indem wir mit list() selbst Listen erstellen.\n\nliste1 &lt;- list(\n  modellname = \"Audi A6\",\n  zulassung = as_date(\"15.05.2013\", format = \"%d.%m.%Y\"),\n  kilometerstand = 115290\n)\n\ntibble1 &lt;- tibble(\n  x = length(letters),\n  y = letters\n)\n\nliste2 &lt;- list(\n  auto = liste1,\n  buchstaben = tibble1\n)\n\nliste3 &lt;- list(\n  vokale = c(\"a\", \"e\", \"i\", \"o\", \"u\"),\n  listen = list(liste1, liste2)\n)\n\nDie hier zu sehenden Listen beinhalten Objekte unterschiedlicher Art, und sie können wiederum Listen enthalten. Wir lassen uns nun Liste 1 ausgeben:\n\nliste1\n\n$modellname\n[1] \"Audi A6\"\n\n$zulassung\n[1] \"2013-05-15\"\n\n$kilometerstand\n[1] 115290\n\n\nWir sehen, dass jedes Element dieser Liste einen Namen (z.B. $modellname) hat. Man kann die Elemente dementsprechend auch über ihren Namen aufrufen:\n\nliste1$modellname\n\n[1] \"Audi A6\"\n\n\nWir schon bei Eingabe des Dollarzeichens Gebrauch von der Autovervollständigung machen: Die Elemente der Liste werden uns sofort angezeigt.\nLeere Listen können auch erstellt werden, zum Beispiel, wenn wir noch nicht wissen, wie viele Elemente welcher Art gesammelt werden sollen:\n\nleere_liste &lt;- list()\n\nWissen wir hingegen, wie viele Elemente wir speichern wollen, können wir folgende Schreibweise verwenden:\n\nliste &lt;- vector(mode = \"list\", length = 5) # 5 durch gewünschte Länge ersetzen\n\nAufgabe 4\nErstelle eine Liste uebe_liste mit den folgenden drei Elementen:\n\nAlle geraden Zahlen von 2 bis 123 (Name: gerade_zahlen)\nAlle großen Buchstaben (Name: alphabet_gross)\nDie Billboard Top 100 aus dem Jahr 2000 (Zu finden unter billboard, Name: top100)\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nEine Abfolge von Zahlen mit einem bestimmten Abstand kann mit seq() erzeugt werden.\n\n\n\n\nLösunguebe_liste &lt;- list(\n  gerade_zahlen = seq(2, 123, by = 2),\n  alphabet_gross = LETTERS,\n  top100 = billboard\n)\n\n\nAufgabe 5\nWas passiert, wenn wir nach dem Erstellen der Liste aus Aufgabe 4 folgenden Code ausführst?\n\nuebe_liste &lt;- c(uebe_liste, list(zahl = 5))\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\nDie Liste uebe_liste wird erweitert mit dem Element zahl.\n\n\n\nOperationen auf Listen\nWollen wir auf einen Teil der Liste zugreifen, so können wir das genau wie bei Vektoren mit folgendermaßen machen:\n\nliste1[1:2] # Gibt die ersten beiden Elemente der Liste (modellname, zulassung)\n\n$modellname\n[1] \"Audi A6\"\n\n$zulassung\n[1] \"2013-05-15\"\n\n\nWir können auch auf genau ein Element der Liste zugreifen:\n\nvokale &lt;- liste3[1]\n\nNehmen wir nun an, wir wollen den vierten Vokal aus vokale ausgeben. Versuchen wir es wie folgt:\n\nvokale[4]\n\n$&lt;NA&gt;\nNULL\n\n\nerhalten wir die Ausgabe $&lt;NA&gt; NULL. Das liegt daran, dass beim Zugreifen auf eine Liste mit einer einfachen eckigen Klammer ([...]) eine Liste mit genau den entsprechenden Inhalten zurückgegeben wird. In unserem Fall ist das eine Liste mit einem Element:\n\nlength(vokale)\n\n[1] 1\n\n\nVersuchen wir nun, auf das vierte Element (in dem Fall der Liste) zuzugreifen, funktioniert das nicht, weil die zurückgegebene Liste eben nur ein Element hat.\nWenn wir das Element selbst (und nicht eine Liste bestehend aus diesem Element) zurückgeben wollen, müssen wir doppelte eckige Klammern ([[...]]) benutzen:\n\nvokale &lt;- liste3[[1]]\n\nvokale[4]\n\n[1] \"o\""
  },
  {
    "objectID": "04-funktionen-und-schleifen.html",
    "href": "04-funktionen-und-schleifen.html",
    "title": "2.2 Schleifen und Funktionen",
    "section": "",
    "text": "Wir werden zwei wichtige Konzepte behandeln - Funktionen und Schleifen. Mit Funktionen können wir einen Code in einen Block auslagern, ihn benennen und wiederbenutzen. Mit Schleifen können wir Code ausführen, bis eine bestimmte Bedingung erfüllt ist.\nSchleifen\n\n# Was macht diese Schleife?\n# (1) Sie definiert die Variable i. Diese Variable nimmt alle Werte von 1 bis 10 an\n# (sie \"iteriert\" über die Zahlen 1 bis 10).\n# (2) Alles, was innerhalb der Schleife steht, kann auf i zugreifen.\n# (3) Im Inneren der Schleife wird der jeweilige Wert von i in die Konsole ausgegeben.\nfor (i in 1:10) {\n  print(i)\n}\n\n\n# Wir können nicht nur über Zahlen iterieren:\nfarben &lt;- c(\"rot\", \"gelb\", \"grün\")\n\n# Es wird das Folgende ausgegeben:\n# Ich mag die Farbe rot\n# Ich mag die Farbe gelb\n# Ich mag die Farbe grün\nfor (farbe in farben) {\n  nachricht &lt;- paste(\"Ich mag die Farbe\", farbe)\n  print(nachricht)\n}\n\nAufgabe 1\nDie Fibonaccifolge ist eine Folge, die mit den Zahlen \\(1, 1, 2, 3, 5, 8, ...\\) beginnt.\n\nWelche Vorschrift beschreibt diese Folge?\nImplementiere die Fibonaccifolge: Schreibe Code, der die ersten 20 Zahlen dieser Folge ausgibt.\n\n\n\n\n\n\n\nLösung 1.\n\n\n\n\n\nDie Vorschrift der Fibonaccifolge lautet \\(F_n=F_{n-1}+F_{n-2}\\).\n\n\n\n\nLösung 2.fib &lt;- rep(NA, 10)\n\nfib[1] &lt;- 1\nfib[2] &lt;- 1\n\nfor (n in 3:length(fib)) {\n  fib[n] &lt;- fib[n-1] + fib[n-2]\n}\n\nfib\n\n\nAufgabe 2\nIllustriere an einem Beispiel, dass folgende Aussage für alle \\(n \\geq 1\\) gilt:\n\\[\nn^2 = \\sum\\limits_{k=1}^n [2k-1]\n\\]\nEs reicht, wenn du beispielsweise alle \\(n \\leq 50\\) betrachtest.\n\n\n\n\n\n\nTipp\n\n\n\n\n\n\\(\\sum\\limits_{k=1}^n [2k-1]\\) kann auch geschrieben werden als \\(1+3+5+...+(2n-1)\\).\n\n\n\n\nLückencode# 2k-1 für 1 &lt;= k &lt;= 50 sind alle ungeraden Zahlen von 1 bis 100.\nx &lt;- seq(from = ..., to = ..., by = ...)\n\n# Wir erstellen einen leeren Vektor y der Länge von x:\ny &lt;- rep(..., length = ...)\n\n# Wir schreiben eine Schleife, die für jedes n &lt;= 50 die Summe von k=1 bis n\n# von 2k-1 berechnet und in y speichert.\nfor (i in 1:length(x)) {\n    y[i] &lt;- sum(...)\n}\n\n# y besteht aus allen Quadratzahlen von 1 bis 50.\ny\n\n\nTODO: map()\nFunktionen\nFunktionen ermöglichen es uns, Code als einen Block zusammenzufassen und wiederzuverwenden. Das ist besonders wichtig, wenn wir immer die gleichen ausgewählten Rechenschritte auf unterschiedlichen Daten durchführen wollen. Gleichzeitig müssen wir den Code nur an einer Stelle umschreiben, wenn wir eine Änderung oder Korrektur vornehmen müssen.\nWir schauen uns im Folgenden eine Abwandlung dieser bayerischen Abituraufgabe an:\n\nEs sei nun \\(X = \\begin{cases} 1 & \\text{Pkw hat Elektromotor} \\\\ 0 & \\text{Pkw hat keinen Elektromotor}\\end{cases}\\) für jedes Auto in der Ziehung. \\(Y\\) ist dann die Zahl der Pkw mit Elektromotor in der Ziehung, also die Summe der Ergebnisse der Ziehung.\nNehmen wir an, es werden von drei Umfrageinstituten jeweils vier dieser Untersuchungen durchgeführt. Die Ergebnisse dieser Umfragen sind in Rohform in der Datei funktionen-ziehungen.csv zu finden.\nAufgabe 3\n\n\nLade die Daten mithilfe der Funktion read_csv() in einen Tibble ziehungen.\n\nLösunglibrary(tidyverse)\n\nziehungen &lt;- \n  read_csv(\"data/funktionen-ziehungen.csv\")\n\n\n\n\nNutze folgenden Codeschnipsel, um aus den gegebenen Daten für \\(X\\ Y\\) zu berechnen. Schlage hierbei mithilfe von ?(Funktion) nach, was diese Funktionen bewirken.\n\ncolnames &lt;- colnames(ziehungen) %&gt;% \n  gsub(\",.*\", \"\", .) %&gt;% \n  unique()\n\nergebnisse &lt;-\n  ziehungen %&gt;% \n  map(sum) %&gt;% \n  matrix(., nrow \n         = 4, ncol = 3, byrow = F,\n         dimnames = list(NULL, colnames)) %&gt;% \n  as_tibble() %&gt;% \n  unnest(cols = all_of(colnames))\n\n\n\nWarum sollte man den folgenden Code durch eine Funktion ersetzen?\n\nstatistiken &lt;- \n  tibble(\n    Statistik = c(\"Mittel\", \"Median\", \"Standardabweichung\"),\n    \"Institut 1\" = c(\n      mean(ergebnisse$`Institut 1`),\n      median(ergebnisse$`Institut 1`),\n      sd(ergebnisse$`Institut 1`)\n    ),\n    \"Institut 2\" = c(\n      mean(ergebnisse$`Institut 2`),\n      median(ergebnisse$`Institut 2`),\n      sd(ergebnisse$`Institut 2`)\n    ),\n    \"Institut 3\" = c(\n      mean(ergebnisse$`Institut 3`),\n      median(ergebnisse$`Institut 3`),\n      sd(ergebnisse$`Institut 3`)\n    )\n  )\n\n\n\nNutze den folgenden Codeschnipsel, um eine Funktion zu schreiben, die für einen Vektor die Statistiken berechnet, und eine andere Funktion, die daraus den obigen Tibble erstellt:\n\nberechne_statistiken &lt;-\n  function(institut) {\n    statistiken &lt;- \n      c(...,\n        ...,\n        ...)\n\n    return(statistiken)\n  }\n\nerstelle_stats_tibble &lt;-\n  function(ergebnisse) {\n    tibble(Statistik = c(...),\n           values =\n             ergebnisse %&gt;% \n             map(...) %&gt;% \n             bind_rows()) %&gt;% \n      unnest(...)\n  }\n\n\nLösungberechne_statistiken &lt;-\n  function(institut) {\n    statistiken &lt;- \n      c(mean(institut),\n        median(institut),\n        sd(institut))\n\n    return(statistiken)\n  }\n\nerstelle_stats_tibble &lt;-\n  function(ergebnisse) {\n    tibble(Statistik = c(\"Mittel\", \"Median\", \"Standardabweichung\"),\n           values =\n             ergebnisse %&gt;% \n             map(berechne_statistiken) %&gt;% \n             bind_rows()) %&gt;% \n      unnest(values)\n  }"
  },
  {
    "objectID": "index.html#vorstellung-der-ag",
    "href": "index.html#vorstellung-der-ag",
    "title": "Willkommen!",
    "section": "Vorstellung der AG",
    "text": "Vorstellung der AG"
  },
  {
    "objectID": "05-visualisierung.html",
    "href": "05-visualisierung.html",
    "title": "2.3 Visualisierung mit Grafiken",
    "section": "",
    "text": "Um uns einen Überblick über die Daten zu verschaffen und einfacher Zusammenhänge zwischen Variablen zu erhalten, ist es oft sinnvoll, Diagramme zu erstellen. R bietet dafür zahlreiche Möglichkeiten, die sehr flexibel genutzt werden können.\nIn dieser Einheit werden wir mit dem Datensatz m111survey aus dem tigerstats-Paket die Grundlagen für eine solche Visualisierung erarbeiten. Dieser Datensatz ist das Ergebnis einer Umfrage unter 71 Studierenden des Georgetown College in Kentucky.\nZunächst laden wir diesen Datensatz in unsere Umgebung.\n\n# install.packages(\"tigerstats\")\n\n\nlibrary(tidyverse)\nlibrary(tigerstats)\n\nMithilfe von ?m111survey können wir uns ansehen, welche Bedeutung die Variablen haben. Man könnte zum Beispiel annehmen, dass Studenten mit niedrigerem Notendurchschnitt eher dazu neigen, schnell zu fahren. Veranschaulichen wir diesen Zusammenhang in einem Diagramm:\n\nm111survey %&gt;% \n  ggplot(aes(x = GPA, y = fastest)) +\n  geom_point()\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nDieses Diagramm ist ein sogenannter Scatterplot bzw. ein Streudiagramm. Der Aufbau eines solchen Diagramms in R ist wie folgt:\n\ndatensatz %&gt;% \n  # Legt den \"Rahmen\" und die Achsen fest\n  ggplot(aes(x = x-Achsen-Variable, y = y-Achsen-Variable)) +\n  geom_... + # Das sogenannte \"Layer\", z.B. Punkte, Linien, Formen, ...\n  ... # Man kann mehrere Layer übereinander legen.\n\nMan könnte denken, dass diese Annahme tatsächlich stimmt. Legen wir mal eine “Ausgleichsgerade” durch die Punkte:\n\nm111survey %&gt;% \n  ggplot(aes(x = GPA, y = fastest)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") # lm steht für \"Linear Model\"\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nDer graue Balken in diesem Diagramm beschreibt im Grunde die Unsicherheit in unserem Modell. Wir sehen, dass er so breit ist, dass die Enden sich jeweils überlappen. Daher können wir nicht darauf schließen, dass der Notenschnitt einen Einfluss auf die höchste je gefahrene Geschwindigkeit hat.\nWir können aber mehr aus den Daten holen. Schauen wir uns zum Beispiel an, wie Frauen im Vergleich zu Männern in der Umfrage antworten:\n\nm111survey %&gt;% \n  ggplot(aes(x = GPA, y = fastest, color = sex)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWir sehen: Frauen haben tendenziell langsamere Höchstgeschwindigkeiten als Männer, aber auch hier überlappen sich die Balken.\nEin weiterer wichtiger Diagrammtyp ist das Histogramm. Es gibt an, wie oft ein bestimmtes “Level” einer Variable in den Daten vorkommt, zum Beispiel wie folgt:\n\nm111survey %&gt;% \n  ggplot(aes(x = fastest)) +\n  geom_histogram(fill = \"burlywood\", color = \"black\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nÄhnliches kann durch das Layer geom_density() erreicht werden. Dieses gibt nicht die Anzahl, sondern die Verteilung der Geschwindigkeiten an.\n\nm111survey %&gt;% \n  ggplot(aes(x = fastest)) +\n  geom_density(fill = \"burlywood\")"
  },
  {
    "objectID": "05-visualisierung.html#grundlagen",
    "href": "05-visualisierung.html#grundlagen",
    "title": "2.3 Visualisierung mit Grafiken",
    "section": "",
    "text": "Um uns einen Überblick über die Daten zu verschaffen und einfacher Zusammenhänge zwischen Variablen zu erhalten, ist es oft sinnvoll, Diagramme zu erstellen. R bietet dafür zahlreiche Möglichkeiten, die sehr flexibel genutzt werden können.\nIn dieser Einheit werden wir mit dem Datensatz m111survey aus dem tigerstats-Paket die Grundlagen für eine solche Visualisierung erarbeiten. Dieser Datensatz ist das Ergebnis einer Umfrage unter 71 Studierenden des Georgetown College in Kentucky.\nZunächst laden wir diesen Datensatz in unsere Umgebung.\n\n# install.packages(\"tigerstats\")\n\n\nlibrary(tidyverse)\nlibrary(tigerstats)\n\nMithilfe von ?m111survey können wir uns ansehen, welche Bedeutung die Variablen haben. Man könnte zum Beispiel annehmen, dass Studenten mit niedrigerem Notendurchschnitt eher dazu neigen, schnell zu fahren. Veranschaulichen wir diesen Zusammenhang in einem Diagramm:\n\nm111survey %&gt;% \n  ggplot(aes(x = GPA, y = fastest)) +\n  geom_point()\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nDieses Diagramm ist ein sogenannter Scatterplot bzw. ein Streudiagramm. Der Aufbau eines solchen Diagramms in R ist wie folgt:\n\ndatensatz %&gt;% \n  # Legt den \"Rahmen\" und die Achsen fest\n  ggplot(aes(x = x-Achsen-Variable, y = y-Achsen-Variable)) +\n  geom_... + # Das sogenannte \"Layer\", z.B. Punkte, Linien, Formen, ...\n  ... # Man kann mehrere Layer übereinander legen.\n\nMan könnte denken, dass diese Annahme tatsächlich stimmt. Legen wir mal eine “Ausgleichsgerade” durch die Punkte:\n\nm111survey %&gt;% \n  ggplot(aes(x = GPA, y = fastest)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") # lm steht für \"Linear Model\"\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nDer graue Balken in diesem Diagramm beschreibt im Grunde die Unsicherheit in unserem Modell. Wir sehen, dass er so breit ist, dass die Enden sich jeweils überlappen. Daher können wir nicht darauf schließen, dass der Notenschnitt einen Einfluss auf die höchste je gefahrene Geschwindigkeit hat.\nWir können aber mehr aus den Daten holen. Schauen wir uns zum Beispiel an, wie Frauen im Vergleich zu Männern in der Umfrage antworten:\n\nm111survey %&gt;% \n  ggplot(aes(x = GPA, y = fastest, color = sex)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWir sehen: Frauen haben tendenziell langsamere Höchstgeschwindigkeiten als Männer, aber auch hier überlappen sich die Balken.\nEin weiterer wichtiger Diagrammtyp ist das Histogramm. Es gibt an, wie oft ein bestimmtes “Level” einer Variable in den Daten vorkommt, zum Beispiel wie folgt:\n\nm111survey %&gt;% \n  ggplot(aes(x = fastest)) +\n  geom_histogram(fill = \"burlywood\", color = \"black\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nÄhnliches kann durch das Layer geom_density() erreicht werden. Dieses gibt nicht die Anzahl, sondern die Verteilung der Geschwindigkeiten an.\n\nm111survey %&gt;% \n  ggplot(aes(x = fastest)) +\n  geom_density(fill = \"burlywood\")"
  },
  {
    "objectID": "05-visualisierung.html#erweiterungen",
    "href": "05-visualisierung.html#erweiterungen",
    "title": "2.3 Visualisierung mit Grafiken",
    "section": "Erweiterungen",
    "text": "Erweiterungen\nThemes\nThemes bestimmen das Aussehen unseres Diagramms, vor allem den Hintergrund und die Markierungen. Standardmäßig haben Diagramme einen grauen Hintergrund mit weißen Gitternetzlinien. Nutzen wir bei unserem Histogramm theme_minimal() als Theme, sieht das folgendermaßen aus:\n\nm111survey %&gt;% \n  ggplot(aes(x = fastest)) +\n  geom_histogram(fill = \"burlywood\", color = \"black\") +\n  theme_minimal()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nDas gleiche Diagramm mit dem theme_bw() sieht so aus:\n\nm111survey %&gt;% \n  ggplot(aes(x = fastest)) +\n  geom_histogram(fill = \"burlywood\", color = \"black\") +\n  theme_bw()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nEs gibt noch zahlreiche weitere Themes, die man mit theme_...() auswählen kann.\nTitel und Beschriftungen\nSo, wie die Diagramme jetzt aussehen, sind sie etwas kahl. Wenn wir sie später irgendwo benutzen wollen, sollten wir sie so formatieren, dass man ihnen den Sinn entnehmen kann. Das können wir mithilfe von Titeln und Beschriftungen erreichen.\nUm einen Titel hinzuzufügen, gibt es das Layer ggtitle(). Es wird folgendermaßen verwendet:\n\nm111survey %&gt;% \n  ggplot(aes(x = fastest)) +\n  geom_histogram(fill = \"burlywood\", color = \"black\") +\n  theme_bw() +\n  ggtitle(\"Höchste je gefahrene Geschwindigkeit\",\n          \"Daten aus einer Befragung unter Studenten des Georgetown College in Kentucky\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nNun sind die Achsenbeschriftungen aber auch noch auf Englisch und nicht sehr deskriptiv. Wir können sie mithilfe von xlab() und ylab() ändern:\n\nm111survey %&gt;% \n  ggplot(aes(x = fastest)) +\n  geom_histogram(fill = \"burlywood\", color = \"black\") +\n  theme_bw() +\n  ggtitle(\"Höchste je gefahrene Geschwindigkeit\",\n          \"Daten aus einer Befragung unter Studenten des Georgetown College in Kentucky\") +\n  xlab(\"Geschwindigkeit in Meilen pro Stunde\") +\n  ylab(\"Anzahl an Angaben\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nWie wir in der Ausgabe sehen, sollte man auch noch die Breite der Säulen festlegen. Das sollte immer im Kontext der Daten erfolgen: Eine Säulenbreite von 50 würde die Daten unzureichend darstellen, während eine Säulenbreite von 1 zu fein ist (eventuell mehrmals nur eine Angabe pro Säule). Eine Säulenbreite von 5 ist wahrscheinlich angemessen:\n\nm111survey %&gt;% \n  ggplot(aes(x = fastest)) +\n  geom_histogram(fill = \"burlywood\", color = \"black\", binwidth = 5) +\n  theme_bw() +\n  ggtitle(\"Höchste je gefahrene Geschwindigkeit\",\n          \"Daten aus einer Befragung unter Studenten des Georgetown College in Kentucky\") +\n  xlab(\"Geschwindigkeit in Meilen pro Stunde\") +\n  ylab(\"Anzahl an Angaben\")\n\n\n\n\nAchsenskalierung\nWir sehen im Diagramm oben, dass wir nur zwei x-Achsen-Markierungen haben, bei 100 und 150 Meilen pro Stunde. Das ist aber relativ wenig. Wir können mehr Markierungen hinzufügen, indem wir festlegen, wo sie zu sehen sein sollen. Ebenso ist unschön, dass wir auf der y-Achse keine ganzen Zahlen haben, obwohl wir nur zählen, wie häufig (ganze Zahlen) die angegebene Geschwindigkeit genannt wird. Auch hier ändern wir die Skala:\n\nm111survey %&gt;% \n  ggplot(aes(x = fastest)) +\n  geom_histogram(fill = \"burlywood\", color = \"black\", binwidth = 5) +\n  theme_bw() +\n  ggtitle(\"Höchste je gefahrene Geschwindigkeit\",\n          \"Daten aus einer Befragung unter Studenten des Georgetown College in Kentucky\") +\n  xlab(\"Geschwindigkeit in Meilen pro Stunde\") +\n  ylab(\"Anzahl an Angaben\") +\n  scale_x_continuous(breaks = c(75, 100, 125, 150, 175)) +\n  scale_y_continuous(breaks = c(0, 2, 4, 6, 8))"
  },
  {
    "objectID": "05-visualisierung.html#weitere-ressourcen",
    "href": "05-visualisierung.html#weitere-ressourcen",
    "title": "2.3 Visualisierung mit Grafiken",
    "section": "Weitere Ressourcen",
    "text": "Weitere Ressourcen\nWelche Mittel man für ein schönes Diagramm braucht, hängt sehr davon ab, welche Art von Daten man hat und was man darstellen möchte. In vielen Fällen ist es das Einfachste, nach den Layern zu googeln, die man benutzen will. Hier sind noch einige weitere Ressourcen, in denen man nachschlagen kann:\n\nDas ggplot2-Cheat Sheet: LINK\nDie ggplot2-Dokumentation: LINK\nEine weitergehende Zusammenfassung der Uni Göttingen: LINK"
  },
  {
    "objectID": "06-textdaten.html",
    "href": "06-textdaten.html",
    "title": "3. Textbasierte Daten",
    "section": "",
    "text": "Bisher haben wir vor allem zahlenbasierte Daten betrachtet, die man beispielsweise in einem Diagramm darstellen und auch empirisch auswerten kann. Für die meisten Anwendungen reicht das vollkommen aus, aber im Internet und auch im Alltag begegnen uns vor allem textbasierte Daten, das heißt Wörter, Sätze, Dokumente und ganze Sammlungen an Texten. In dieser Einheit wagen wir einen Exkurs hin zu dieser Art von Daten, mit denen wir ganz andere Untersuchungen anstellen können als mit Zahlen allein. Zum Beispiel können wir untersuchen:\n\nWelche Wörter in einer Sorte Text am häufigsten vorkommen und sie mit anderen Texten vergleichen\nWie die Stimmung (das Sentiment) dieser Texte ist oder\nOb es bei Immobilien einen Zusammenhang zwischen Wortwahl und Kaufpreis gibt.\n\nUm diesen Zielen näher zu kommen, benutzen wir die Datei angebote_1000.csv. Sie enthält Daten zu über 200.000 Immobilienangeboten aus den Jahren 2018 und 2019. Diese Daten wurden entnommen aus diesem Kaggle-Datensatz und stammen von der Seite immobilienscout24.de.\nZunächst laden wir die Daten in unseren Arbeitsbereich und schauen sie uns an:"
  },
  {
    "objectID": "06-textdaten.html#warum-textbasierte-daten",
    "href": "06-textdaten.html#warum-textbasierte-daten",
    "title": "3. Textbasierte Daten",
    "section": "",
    "text": "Bisher haben wir vor allem zahlenbasierte Daten betrachtet, die man beispielsweise in einem Diagramm darstellen und auch empirisch auswerten kann. Für die meisten Anwendungen reicht das vollkommen aus, aber im Internet und auch im Alltag begegnen uns vor allem textbasierte Daten, das heißt Wörter, Sätze, Dokumente und ganze Sammlungen an Texten. In dieser Einheit wagen wir einen Exkurs hin zu dieser Art von Daten, mit denen wir ganz andere Untersuchungen anstellen können als mit Zahlen allein. Zum Beispiel können wir untersuchen:\n\nWelche Wörter in einer Sorte Text am häufigsten vorkommen und sie mit anderen Texten vergleichen\nWie die Stimmung (das Sentiment) dieser Texte ist oder\nOb es bei Immobilien einen Zusammenhang zwischen Wortwahl und Kaufpreis gibt.\n\nUm diesen Zielen näher zu kommen, benutzen wir die Datei angebote_1000.csv. Sie enthält Daten zu über 200.000 Immobilienangeboten aus den Jahren 2018 und 2019. Diese Daten wurden entnommen aus diesem Kaggle-Datensatz und stammen von der Seite immobilienscout24.de.\nZunächst laden wir die Daten in unseren Arbeitsbereich und schauen sie uns an:"
  },
  {
    "objectID": "06-textdaten.html#datenprojekt",
    "href": "06-textdaten.html#datenprojekt",
    "title": "3. Textbasierte Daten",
    "section": "Datenprojekt",
    "text": "Datenprojekt\nDaten vorbereiten\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ninserate &lt;- read_csv(\"data/angebote_1000.csv\")\n\nRows: 1000 Columns: 49\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (20): regio1, heatingType, telekomTvOffer, firingTypes, geo_bln, houseNu...\ndbl (23): serviceCharge, telekomHybridUploadSpeed, picturecount, pricetrend,...\nlgl  (6): newlyConst, balcony, hasKitchen, cellar, lift, garden\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ninserate\n\n# A tibble: 1,000 × 49\n   regio1        serviceCharge heatingType telekomTvOffer telekomHybridUploadS…¹\n   &lt;chr&gt;                 &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;                           &lt;dbl&gt;\n 1 Nordrhein_We…         245   central_he… ONE_YEAR_FREE                      NA\n 2 Rheinland_Pf…         134   self_conta… ONE_YEAR_FREE                      NA\n 3 Sachsen               255   floor_heat… ONE_YEAR_FREE                      10\n 4 Sachsen                58.2 district_h… ONE_YEAR_FREE                      NA\n 5 Bremen                138   self_conta… &lt;NA&gt;                               NA\n 6 Sachsen                70   self_conta… ONE_YEAR_FREE                      10\n 7 Bremen                 88   central_he… ONE_YEAR_FREE                      10\n 8 Baden_Württe…         110   oil_heating ONE_YEAR_FREE                      NA\n 9 Nordrhein_We…          95   self_conta… ONE_YEAR_FREE                      NA\n10 Sachsen                88   &lt;NA&gt;        ONE_YEAR_FREE                      NA\n# ℹ 990 more rows\n# ℹ abbreviated name: ¹​telekomHybridUploadSpeed\n# ℹ 44 more variables: newlyConst &lt;lgl&gt;, balcony &lt;lgl&gt;, picturecount &lt;dbl&gt;,\n#   pricetrend &lt;dbl&gt;, telekomUploadSpeed &lt;dbl&gt;, totalRent &lt;dbl&gt;,\n#   yearConstructed &lt;dbl&gt;, scoutId &lt;dbl&gt;, noParkSpaces &lt;dbl&gt;,\n#   firingTypes &lt;chr&gt;, hasKitchen &lt;lgl&gt;, geo_bln &lt;chr&gt;, cellar &lt;lgl&gt;,\n#   yearConstructedRange &lt;dbl&gt;, baseRent &lt;dbl&gt;, houseNumber &lt;chr&gt;, …\n\n\nWir können uns auch anschauen, welche Spalten es gibt und welches Format sie haben:\n\ninserate %&gt;% \n  glimpse()\n\nRows: 1,000\nColumns: 49\n$ regio1                   &lt;chr&gt; \"Nordrhein_Westfalen\", \"Rheinland_Pfalz\", \"Sa…\n$ serviceCharge            &lt;dbl&gt; 245.00, 134.00, 255.00, 58.15, 138.00, 70.00,…\n$ heatingType              &lt;chr&gt; \"central_heating\", \"self_contained_central_he…\n$ telekomTvOffer           &lt;chr&gt; \"ONE_YEAR_FREE\", \"ONE_YEAR_FREE\", \"ONE_YEAR_F…\n$ telekomHybridUploadSpeed &lt;dbl&gt; NA, NA, 10, NA, NA, 10, 10, NA, NA, NA, 10, N…\n$ newlyConst               &lt;lgl&gt; FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALS…\n$ balcony                  &lt;lgl&gt; FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, F…\n$ picturecount             &lt;dbl&gt; 6, 8, 8, 9, 19, 9, 5, 5, 7, 11, 9, 4, 3, 12, …\n$ pricetrend               &lt;dbl&gt; 4.62, 3.47, 2.72, 1.53, 2.46, 1.01, 1.89, 3.7…\n$ telekomUploadSpeed       &lt;dbl&gt; 10.0, 10.0, 2.4, 40.0, NA, 2.4, 2.4, 40.0, 40…\n$ totalRent                &lt;dbl&gt; 840.00, NA, 1300.00, NA, 903.00, 380.00, 584.…\n$ yearConstructed          &lt;dbl&gt; 1965, 1871, 2019, 1964, 1950, NA, 1959, 1970,…\n$ scoutId                  &lt;dbl&gt; 96107057, 111378734, 113147523, 108890903, 11…\n$ noParkSpaces             &lt;dbl&gt; 1, 2, 1, NA, NA, NA, NA, 1, NA, NA, NA, NA, N…\n$ firingTypes              &lt;chr&gt; \"oil\", \"gas\", NA, \"district_heating\", \"gas\", …\n$ hasKitchen               &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FAL…\n$ geo_bln                  &lt;chr&gt; \"Nordrhein_Westfalen\", \"Rheinland_Pfalz\", \"Sa…\n$ cellar                   &lt;lgl&gt; TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, …\n$ yearConstructedRange     &lt;dbl&gt; 2, 1, 9, 2, 1, NA, 2, 2, 2, 1, 1, 1, 2, 9, 4,…\n$ baseRent                 &lt;dbl&gt; 595.00, 800.00, 965.00, 343.00, 765.00, 310.0…\n$ houseNumber              &lt;chr&gt; \"244\", NA, \"4\", \"35\", \"10\", \"14\", \"35\", NA, \"…\n$ livingSpace              &lt;dbl&gt; 86.00, 89.00, 83.80, 58.15, 84.97, 62.00, 60.…\n$ geo_krs                  &lt;chr&gt; \"Dortmund\", \"Rhein_Pfalz_Kreis\", \"Dresden\", \"…\n$ condition                &lt;chr&gt; \"well_kept\", \"refurbished\", \"first_time_use\",…\n$ interiorQual             &lt;chr&gt; \"normal\", \"normal\", \"sophisticated\", NA, NA, …\n$ petsAllowed              &lt;chr&gt; NA, \"no\", NA, NA, NA, NA, NA, \"no\", \"negotiab…\n$ street                   &lt;chr&gt; \"Sch&uuml;ruferstra&szlig;e\", \"no_information…\n$ streetPlain              &lt;chr&gt; \"Schüruferstraße\", NA, \"Turnerweg\", \"Glück-Au…\n$ lift                     &lt;lgl&gt; FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALS…\n$ baseRentRange            &lt;dbl&gt; 4, 5, 6, 2, 5, 2, 3, 4, 1, 1, 2, 5, 6, 6, 1, …\n$ typeOfFlat               &lt;chr&gt; \"ground_floor\", \"ground_floor\", \"apartment\", …\n$ geo_plz                  &lt;chr&gt; \"44269\", \"67459\", \"01097\", \"09599\", \"28213\", …\n$ noRooms                  &lt;dbl&gt; 4.0, 3.0, 3.0, 3.0, 3.0, 2.0, 3.0, 2.0, 2.5, …\n$ thermalChar              &lt;dbl&gt; 181.40, NA, NA, 86.00, 188.90, NA, 63.00, 138…\n$ floor                    &lt;dbl&gt; 1, NA, 3, 3, 1, 1, NA, 2, 2, 3, 1, NA, 4, 0, …\n$ numberOfFloors           &lt;dbl&gt; 3, NA, 4, NA, NA, 4, NA, 2, 5, NA, NA, NA, 4,…\n$ noRoomsRange             &lt;dbl&gt; 4, 3, 3, 3, 3, 2, 3, 2, 2, 2, 3, 4, 4, 3, 1, …\n$ garden                   &lt;lgl&gt; TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE…\n$ livingSpaceRange         &lt;dbl&gt; 4, 4, 4, 2, 4, 3, 2, 2, 2, 1, 3, 4, 6, 4, 1, …\n$ regio2                   &lt;chr&gt; \"Dortmund\", \"Rhein_Pfalz_Kreis\", \"Dresden\", \"…\n$ regio3                   &lt;chr&gt; \"Schüren\", \"Böhl_Iggelheim\", \"Äußere_Neustadt…\n$ description              &lt;chr&gt; \"Die ebenerdig zu erreichende Erdgeschosswohn…\n$ facilities               &lt;chr&gt; \"Die Wohnung ist mit Laminat ausgelegt. Das B…\n$ heatingCosts             &lt;dbl&gt; NA, NA, NA, 87.23, NA, NA, 44.00, NA, NA, NA,…\n$ energyEfficiencyClass    &lt;chr&gt; NA, NA, NA, NA, NA, NA, \"B\", \"E\", NA, NA, NA,…\n$ lastRefurbish            &lt;dbl&gt; NA, 2019, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ electricityBasePrice     &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ electricityKwhPrice      &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ date                     &lt;chr&gt; \"May19\", \"May19\", \"Oct19\", \"May19\", \"Feb20\", …\n\n\nFokussieren wir uns auf die Spalten totalRent, description und facilities, sowie die scoutId, die das jeweilige Angebot identifiziert.\n\ninserate_textdaten &lt;-\n  inserate %&gt;% \n  select(scoutId, totalRent, description, facilities)\n\ninserate_textdaten\n\n# A tibble: 1,000 × 4\n     scoutId totalRent description                                    facilities\n       &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                                          &lt;chr&gt;     \n 1  96107057      840  \"Die ebenerdig zu erreichende Erdgeschosswohn… \"Die Wohn…\n 2 111378734       NA  \"Alles neu macht der Mai – so kann es auch fü…  &lt;NA&gt;     \n 3 113147523     1300  \"Der Neubau entsteht im Herzen der Dresdner N… \"* 9 m² B…\n 4 108890903       NA  \"Abseits von Lärm und Abgasen in Ihre neue Wo…  &lt;NA&gt;     \n 5 114751222      903  \"Es handelt sich hier um ein saniertes Mehrfa… \"Diese Wo…\n 6 114391930      380  \"Am Bahnhof 14 in Freiberg\\nHeizkosten und Wa…  &lt;NA&gt;     \n 7 115270775      584. \"+ Komfortabler Bodenbelag: Die Wohnung ist z… \"Rollläde…\n 8 106416361      690  \"Diese ansprechende, lichtdurchflutete DG-Woh… \"Parkett,…\n 9  91383597       NA  \"Sie sind auf der Suche nach einer gepflegten… \"In Ihrem…\n10 112923517      307  \"Gemütliche 2-Raum Wohnung in Chemnitz.  komp…  &lt;NA&gt;     \n# ℹ 990 more rows\n\n\nWir wollen nur Angebote betrachten, die einen Preis sowie eine generelle Beschreibung haben.\n\nrelevante_inserate &lt;-\n  inserate_textdaten %&gt;% \n  drop_na(totalRent, description)\n\nrelevante_inserate\n\n# A tibble: 855 × 4\n     scoutId totalRent description                                    facilities\n       &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                                          &lt;chr&gt;     \n 1  96107057      840  \"Die ebenerdig zu erreichende Erdgeschosswohn… \"Die Wohn…\n 2 113147523     1300  \"Der Neubau entsteht im Herzen der Dresdner N… \"* 9 m² B…\n 3 114751222      903  \"Es handelt sich hier um ein saniertes Mehrfa… \"Diese Wo…\n 4 114391930      380  \"Am Bahnhof 14 in Freiberg\\nHeizkosten und Wa…  &lt;NA&gt;     \n 5 115270775      584. \"+ Komfortabler Bodenbelag: Die Wohnung ist z… \"Rollläde…\n 6 106416361      690  \"Diese ansprechende, lichtdurchflutete DG-Woh… \"Parkett,…\n 7 112923517      307  \"Gemütliche 2-Raum Wohnung in Chemnitz.  komp…  &lt;NA&gt;     \n 8 109842225      555  \"Gern möchten wir Ihnen diese 3-Zimmer-Wohnun… \"- Wohnzi…\n 9 111251778      920  \"Altes Sandsteinhaus unter Denkmalschutz im J… \"Die Char…\n10 101730329     1150  \"Die angebotene Wohnfläche befindet sich im d… \"Die Wohn…\n# ℹ 845 more rows\n\n\nWie wir sehen können, gibt es in den Beschreibungstexten die Zeichenfolge \\n. Diese beschreibt einen Zeilenumbruch (das, was erzeugt wird, wenn man die Entertaste drückt). Wir möchten diese durch ein Leerzeichen ersetzen. Das geht folgendermaßen:\n\nrelevante_inserate &lt;-\n  relevante_inserate %&gt;% \n  mutate(description = str_replace_all(description, \"\\n\", \" \"),\n         facilities = str_replace_all(facilities, \"\\n\", \" \"))\n\nNach diesem Entfernen können wir zum Beispiel die erste Beschreibung ganz normal lesen:\n\nrelevante_inserate %&gt;% \n  select(description) %&gt;%\n  head(1) %&gt;% \n  pull()\n\n[1] \"Die ebenerdig zu erreichende Erdgeschosswohnung befindet sich in einem gepflegten 8-Familienhaus. Aufgrund der Hanglage bietet sich ein unverbaubarer Blick ins Grüne.\"\n\n\nDaten analysieren\nWir können nun mit den Daten arbeiten. Schauen wir uns zum Beispiel einmal an, welche Wörter am häufigsten in den Inseratsbeschreibungen vorkommen.\nHierfür brauchen wir die Library tidytext.\n\ninstall.packages(\"tidytext\")\n\n\nlibrary(tidytext)\n\ntokens &lt;- \n  relevante_inserate %&gt;%\n  select(description) %&gt;%\n  unnest_tokens(input = description,\n                output = word,\n                to_lower = TRUE)\n\nHäufigkeitsliste\nDer obenstehende Code erzeugt einen Tibble mit allen Wörtern (tokens), die in den Texten vorkommen. Wir können nun ausgeben lassen, wie oft jedes Wort vorkommt und die Wörter nach Häufigkeit sortieren:\n\ntokens %&gt;% \n  count(word, sort = TRUE) \n\n# A tibble: 8,041 × 2\n   word        n\n   &lt;chr&gt;   &lt;int&gt;\n 1 und      1931\n 2 die      1522\n 3 mit      1326\n 4 in       1234\n 5 der      1075\n 6 wohnung   967\n 7 ein       821\n 8 im        791\n 9 sich      756\n10 das       706\n# ℹ 8,031 more rows\n\n\nWir sehen, dass Wörter wie “und”, “die”, “mit”, … besonders häufig vorkommen, also Wörter, die keinen Aufschluss über den Inhalt der Beschreibung geben. Wir können diese Wörter, die sogenannten Stoppwörter, entfernen. Hierfür brauchen wir die Library stopwords.\n\ninstall.packages(\"stopwords\")\n\n\nstoppwoerter &lt;- \n  get_stopwords(\"de\") %&gt;% \n  pull(word)\n\ntokens_relevant &lt;-\n  tokens %&gt;% \n  filter(!word %in% stoppwoerter)\n\n\nhaeufigkeitsliste &lt;-\n  tokens_relevant %&gt;% \n  count(word, sort = TRUE)\n\nhaeufigkeitsliste\n\n# A tibble: 7,875 × 2\n   word         n\n   &lt;chr&gt;    &lt;int&gt;\n 1 wohnung    967\n 2 befindet   311\n 3 zimmer     293\n 4 2          289\n 5 küche      256\n 6 balkon     218\n 7 sowie      214\n 8 3          200\n 9 wurde      200\n10 verfügt    184\n# ℹ 7,865 more rows\n\n\nWir sehen, dass das häufigste (relevante) Wort in unseren Inseraten “Wohnung” ist, was nicht überraschend ist (wir betrachten Wohnungsinserate).\nWordwolke\nMithilfe der Häufigkeitsliste können wir eine Wordwolke erstellen. Dafür brauchen wir die Library wordcloud:\n\ninstall.packages(\"wordcloud\")\n\n\nlibrary(wordcloud)\n\nLade nötiges Paket: RColorBrewer\n\n\n\nwordcloud(\n  words = haeufigkeitsliste$word,\n  freq = haeufigkeitsliste$n\n)\n\nWir sehen: das sind zu viele Wörter für eine Wortwolke. Nehmen wir die 100 häufigsten Wörter:\n\nwordcloud(\n  words = haeufigkeitsliste$word[1:100],\n  freq = haeufigkeitsliste$n[1:100]\n)\n\n\n\n\nSentimentanalyse\nNun haben wir uns angesehen, welche Wörter in den Beschreibungstexten häufig vorkommen. Nun wollen wir die Texte aber weiter auf ihre Stimmung analysieren. Im Deutschen ist das nicht ganz so komfortabel möglich wie im Englischen, wo zahlreiche Libraries zur Verfügung stehen.\nWas benötigen wir, um einen Text auf seine Stimmung hin zu analysieren?\n\nDen Text, den wir analysieren wollen\nEine Liste, die jedem Wort eine Stimmung zuordnet (positiv, negativ, neutral, …)\n\nWir beginnen mit dem zweiten Schritt und laden eine Wortliste herunter, die deutsche Wörter enthält. Hierzu hat der Nutzer georgeblck auf GitHub ein Skript geschrieben, das unter diesem Link eingesehen und in veränderter Form unter diesem Link heruntergeladen werden kann.\nWir können das Skript komplett ausführen, indem wir auf Source gehen (rechts oben in der Leiste über dem Code). Der Dataframe sentiDat ist dann unsere Wortliste. Falls etwas nicht funktioniert, kann sie auch unter diesem Link heruntergeladen werden und dann mit diesem Code in den Arbeitsbereich geladen werden:\n\n# \"data/\" etc. hängt natürlich vom Speicherort ab\nsentiDat &lt;- read_csv(\"data/sentiment_liste.csv\")\n\nRows: 34603 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): type, POS, Wort\ndbl (1): Wert\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nSchauen wir uns diese Liste oder auch Lexikon einmal an.\n\nsentiDat\n\n# A tibble: 34,603 × 4\n   type     Wert POS   Wort          \n   &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;         \n 1 neg   -0.058  NN    abbaus        \n 2 neg   -0.0048 NN    abbruches     \n 3 neg   -0.0048 NN    abdankungen   \n 4 neg   -0.0048 NN    abdämpfungen  \n 5 neg   -0.0048 NN    abfalles      \n 6 neg   -0.337  NN    abfuhren      \n 7 neg   -0.346  NN    abgründe      \n 8 neg   -0.365  NN    abhängigkeiten\n 9 neg   -0.512  NN    ablehnungen   \n10 neg   -0.0435 NN    ablenkungen   \n# ℹ 34,593 more rows\n\n\nEine Erklärung der Spalten:\n\ntype: ist das Wort positiv (pos) oder negativ (neg)?\nWert: wie positiv (+) /negativ (-) ist das Wort? (Von -1 bis 1)\nPOS: Part Of Speech: Welche Funktion hat das Wort? (NN: Nomen, VVINF: Verben, ADJX: Adjektive, ADV: Adverbien)\nWort: das gefragte Wort\n\nWir wollen nun unsere Daten so vorbereiten, dass wir am Ende für jedes Inserat einen Sentiment-Score erhalten. Dazu füllen wir die Inserate in eine Liste (jedes Element = ein Inserat) und teilen die Inseratstexte auf in Token (wir erhalten eine Liste mit jedem Element = Tibble der Tokens).\n\nrelevante_inserate %&gt;%\n  select(description) %&gt;%\n  apply(1, \\(x) tibble(description = x)) %&gt;% \n  as.list() -&gt; beschreibung_liste\n\n\ntoken_liste &lt;- \n  beschreibung_liste %&gt;% \n  map(\\(x) unnest_tokens(x, word, description))\n\nNach diesem Aufteilen wollen wir endlich zur Sentimentanalyse kommen. Hierzu suchen wir für jedes Wort, das in der Token-Liste vorkommt, seinen Wert im Lexikon und vereinen diese beiden Einträge zu einer Zeile im jeweiligen Tibble in der Token-Liste.\nHierzu ein Exkurs zu Joins.\nJoins\nWer bereits SQL kennt, denen wird der Begriff des Joins etwas sagen. Vereinfacht dargestellt ist ein Join nichts anderes als ein Zusammenfügen zweier Tabellen anhand eines gemeinsamen Kriteriums. Wir werden in diesem Kontext drei Joins besprechen:\n\nLeft Join (analog: Right Join)\nInner Join\nFull Join\n\nLeft Join\n\nInner Join\n\nFull Join\n\nWir führen nun einen Inner Join für jedes Inserat durch. Dabei ist die linke Tabelle unsere Token-Liste und die rechte Tabelle das Lexikon.\nHierzu benötigen wir die Library udpipe, die es uns erlaubt, die Grundformen von Wörtern zu bestimmen (im Lexikon stehen oft nur die Grundformen). Wir filtern die Token nach Adjektiven, Nomen und Verben (wir lassen Wörter wie “der/die/das”, “welcher/welche/welches”, Satzzeichen und Zahlen aus) und führen dann den Join durch. Für jedes Inserat berechnen wir dann das durchschnittliche Sentiment und schließlich den Durchschnitt über alle Inserate.\n\n# install.packages(\"udpipe\")\n\nlibrary(udpipe)\n\n# ud_model &lt;- udpipe_download_model(\"german\")\nud_model &lt;- udpipe_load_model(\"german-gsd-ud-2.5-191206.udpipe\")\n\ntoken_liste &lt;- \n  beschreibung_liste %&gt;% \n  map(\\(x) pull(x)) %&gt;% \n  map(\\(x) {\n    udpipe_annotate(ud_model, x) %&gt;% \n      as.data.frame() %&gt;% \n      filter(upos %in% c(\"ADJ\", \"NOUN\", \"VERB\")) %&gt;% \n      select(lemma)\n  })\n\n\nsentiment_list &lt;- list()\n\nsentiDat %&gt;% \n  distinct(Wort, .keep_all = T) -&gt; sentiDat\n\nfor (i in seq_along(token_liste)) {\n  sentiment_list[[i]] &lt;-\n    token_liste[[i]] %&gt;%\n    inner_join(sentiDat, by = join_by(lemma == Wort))\n}\n\nsentiment_list %&gt;% \n  map(\\(x) {\n    x %&gt;% \n      summarise(sentiment = mean(Wert)) %&gt;% \n      pull()\n  }) %&gt;% \n  unlist() -&gt; sentimente\n\nmean(sentimente, na.rm = TRUE)\n\n[1] 0.1537123\n\n\nWir sehen: Mit ungefähr \\(0,154\\) ist das Durchschnittssentiment deutlich über 0. Die Wohnungsinserate sind also sehr positiv formuliert."
  },
  {
    "objectID": "07-statistik.html",
    "href": "07-statistik.html",
    "title": "4. Nützliche Statistik",
    "section": "",
    "text": "Auch wenn diese AG nur eine Einführung in die Arbeit mit Daten bieten kann, ist es von Vorteil, wenn man einige Methoden zu deren Auswertung kennt."
  },
  {
    "objectID": "07-1-mathematik-ols.html",
    "href": "07-1-mathematik-ols.html",
    "title": "4E1 Herleitung des Kleinste-Quadrate-Schätzers",
    "section": "",
    "text": "Um zu verstehen, wie die Methode der kleinsten Quadrate funktioniert, ist es sinnvoll, sich der Sache mathematisch zu nähern.\nWir wollen durch unsere Datenpunkte eine Gerade so legen, dass sie in der Mitte durch unsere Punkte geht. Dabei können wir die Datenpunkte als Punkte \\(P_i(x_i|y_i)\\) im zweidimensionalen Koordinatensystem beschreiben. Für die Gerade können wir dann die Funktion \\(\\hat{y}=a+bx\\) formulieren, wobei wir \\(a\\) und \\(b\\) mithilfe unserer Punkte berechnen müssen.\nSchauen wir uns einen Punkt \\(P_n(x_n|y_n)\\) an. Er liegt mit einem gewissen Abstand zu der später aufgestellten Gerade (der Abstand kann auch 0 sein).\n\nWir können (das ist später hilfreich) diesen Abstand durch ein Quadrat ersetzen, denn ansonsten müssen wir mit Beträgen arbeiten. Das geht, denn wenn wir die Summe der Quadrate minimieren, minimieren wir auch die Abstände der Punkte zur Ausgleichsgeraden.\n\nWir können die Fläche des Quadrats schreiben als \\((y_n-\\hat{y}_n)^2\\). Dabei ist \\(\\hat{y}_n\\) der y-Wert der Ausgleichsgeraden an der Stelle \\(x_n\\) (unsere Gerade hat die Gleichung \\(\\hat{y}=a+bx\\)).\nNummerieren wir nun die \\(N=4\\) Quadrate von 1 bis 4:\n\nDie Summe aller Quadrate ist folglich \\(\\sum\\limits_{i=1}^{N}(y_i-\\hat{y}_i)^2\\). Wir wissen: \\(\\hat{y}_i=a+bx_i\\), also ist die Summe aller Quadrate \\(\\sum\\limits_{i=1}^{N}(y_i-a-bx_i)^2\\). Nennen wir diesen Term \\(r(a,b)\\).\nNun wollen wir \\(a\\) und \\(b\\) berechnen, so dass der Abstand der Punkte zur Geraden minimal wird, also müssen wir nach der vorherigen Umformulierung die Summe aller Quadrate minimieren.\n\n1) a berechnen\nUm den Wert für \\(a\\) zu berechnen, für den der Term \\(r(a,b)\\) minimal wird, müssen wir ihn nach \\(a\\) ableiten und gleich 0 setzen.\n\\[\nr(a,b) = \\sum\\limits_{i=1}^N (y_i-a-bx_i)^2\n\\]\n\\[\nr'_a(a,b) = 0 = \\sum\\limits_{i=1}^N 2\\cdot (-1) \\cdot (y_i-a-bx_i)\n\\]\n\\[\n0 = 2\\cdot (-1)\\cdot \\sum\\limits_{i=1}^N (y_i-a-bx_i)\n\\]\n\\[\n0 = \\sum\\limits_{i=1}^N (y_i-a-bx_i)\n\\]\n\\[\n0 = \\sum\\limits_{i=1}^N y_i - \\sum\\limits_{i=1}^N a - b \\sum\\limits_{i=1}^N x_i\n\\]\n\\[\n0 = \\sum\\limits_{i=1}^N y_i - N \\cdot a - b \\sum\\limits_{i=1}^N x_i\n\\]\n\\[\nN \\cdot a = \\sum\\limits_{i=1}^N y_i - b \\sum\\limits_{i=1}^N x_i\n\\]\n\\[\na = \\frac{\\sum\\limits_{i=1}^N y_i - b \\sum\\limits_{i=1}^N x_i}{N}\n\\]\n\\[\na = \\frac{\\sum\\limits_{i=1}^N y_i}{N} - b \\frac{\\sum\\limits_{i=1}^N x_i}{N}\n\\]\n\\[\n\\underline{\\underline{a = \\bar{y}-b\\bar{x}}}\n\\]\n\\(\\bar{y}\\) bzw. \\(\\bar{x}\\) beschreiben hier den Mittelwert von \\(y\\) bzw. \\(x\\).\n\n2) b berechnen\nWir beginnen erneut mit unserer Formel für die Summe der Quadrate:\n\\[\nr(a,b) = \\sum\\limits_{i=1}^N (y_i-a-bx_i)^2\n\\]\n\\[\nr'_b(a,b)= 0 =\\sum\\limits_{i=1}^N 2 \\cdot (-x_i)\\cdot (y_i-a-bx_i)\n\\]\n\\[\n0 = -2 \\cdot \\sum\\limits_{i=1}^N x_i \\cdot (y_i-a-bx_i)\n\\]\nNun können wir für \\(a\\) direkt den Wert von oben einsetzen:\n\\[\n0 = -2 \\cdot \\sum\\limits_{i=1}^{N} x_i \\cdot (y_i - (\\bar{y} - b\\bar{x}) - bx_i)\n\\]\n\\[\n0 = \\sum\\limits_{i=1}^{N} (x_iy_i - x_i\\bar{y} + b\\bar{x}x_i - bx_i^2)\n\\]\n\\[\n0 = \\sum\\limits_{i=1}^{N} (x_iy_i - x_i\\bar{y} - b \\cdot (x_i^2 - \\bar{x}x_i) )\n\\]\n\\[\n0 = \\sum\\limits_{i=1}^{N} (x_iy_i-x_i\\bar{y}) - b\\sum\\limits_{i=1}^{N} (x_i^2-\\bar{x}x_i)\n\\]\n\\[\nb\\sum\\limits_{i=1}^{N} (x_i^2-\\bar{x}x_i) = \\sum\\limits_{i=1}^{N} (x_iy_i-x_i\\bar{y})\n\\]\n\\[\nb = \\frac{\\sum\\limits_{i=1}^{N} (x_iy_i-x_i\\bar{y})}{\\sum\\limits_{i=1}^{N} (x_i^2-\\bar{x}x_i)}\n\\]\n\\[\n\\underline{\\underline{b = \\frac{\\sum\\limits_{i=1}^N x_iy_i - n\\bar{x}\\bar{y}}{\\sum\\limits_{i=1}^N x_i^2 - n\\bar{x}^2}}}\n\\]\nMan kann die Formel für \\(b\\) so umstellen, das es leichter gelesen werden kann: \\(b =\\frac{\\sum\\limits_{i=1}^N (x_i-\\bar{x})(y_i-\\bar{y})}{\\sum\\limits_{i=1}^N (x_i-\\bar{x})^2}\\).\nNun können wir die “optimale” Ausgleichsgerade finden, indem wir die Werte für \\(x_i\\) und \\(y_i\\) einsetzen."
  },
  {
    "objectID": "07-statistik.html#methode-der-kleinsten-quadrateordinary-least-squares",
    "href": "07-statistik.html#methode-der-kleinsten-quadrateordinary-least-squares",
    "title": "4. Nützliche Statistik",
    "section": "Methode der kleinsten Quadrate/Ordinary Least Squares",
    "text": "Methode der kleinsten Quadrate/Ordinary Least Squares\nDie Methode der kleinsten Quadrate erlaubt es uns, eine optimale Ausgleichsgerade \\(y = a + bx\\) zu finden. Dabei wird die Gerade so gelegt, dass die Summe der Abstände aller Datenpunkte minimal wird:\n\nZur mathematischen Herleitung der Gleichung für diese Gerade geht es hier entlang."
  },
  {
    "objectID": "07-statistik.html#das-lineare-modell-und-statistische-signifikanz",
    "href": "07-statistik.html#das-lineare-modell-und-statistische-signifikanz",
    "title": "4. Nützliche Statistik",
    "section": "Das lineare Modell und statistische Signifikanz",
    "text": "Das lineare Modell und statistische Signifikanz\nNun wissen wir, dass es eine Methode gibt, mit der wir eine Ausgleichsgerade durch Punkte legen können. Das hat einen Nutzen für uns, wenn wir den Zusammenhang zwischen zwei Variablen erkennen wollen.\nSimulieren wir einen Zusammenhang zwischen \\(x\\) und \\(y\\), indem wir Datenpunkte mit Koordinaten \\(x\\) und \\(y\\) erzeugen, die sich um die Gerade \\(y = \\frac{1}{3}x\\) herum befinden, wobei wir einen Fehlerterm verwenden, damit die Punkte nicht genau auf der Geraden liegen.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nset.seed(1) # Daten sollen immer gleich erzeugt werden\n\nx &lt;- rnorm(n = 100, mean = 3, sd = 1)\nfehler &lt;- rnorm(n = 100, mean = 0, sd = 0.5)\ny &lt;- 1/3 * x + fehler\n\n# Ein Diagramm nur mit Angabe von x und y\nqplot(x, y) +\n  geom_smooth(method = \"lm\")\n\nWarning: `qplot()` was deprecated in ggplot2 3.4.0.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nIn diesem Fall haben wir folgenden Zusammenhang konstruiert: wenn \\(x\\) um eine Einheit größer wird, nimmt \\(y\\) um \\(\\frac{1}{3}\\) Einheit zu.\nHätten wir diese Daten nicht selbst erzeugt, sondern aus der realen Welt entnommen, könnten wir uns jetzt fragen: gibt es in Wirklichkeit einen Zusammenhang zwischen \\(x\\) und \\(y\\)? Das können wir natürlich nie zu 100 Prozent überprüfen, aber wir können testen, ob wir den Zusammenhang mit großer Sicherheit annehmen können.\nDazu können wir in R mit der oben genannten Methode der kleinsten Quadrate die Ausgleichsgerade konstruieren und den sogenannten p-Wert für die Steigung dieser Geraden ablesen:\n\nausgleichsgerade &lt;- lm(y ~ x) # Konstruktion einer Ausgleichsgeraden\n\nausgleichsgerade %&gt;% \n  summary() # Anzeige der Werte von a (Intercept) und b (x) für diese Gerade\n\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.93842 -0.30688 -0.06975  0.26970  1.17309 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -0.01726    0.17424  -0.099    0.921    \nx            0.33280    0.05386   6.179 1.48e-08 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4814 on 98 degrees of freedom\nMultiple R-squared:  0.2803,    Adjusted R-squared:  0.273 \nF-statistic: 38.18 on 1 and 98 DF,  p-value: 1.479e-08\n\n\nDer p-Wert ist unter Pr(&gt;|t|) angegeben. Vereinfacht gesagt gibt er an, wie wahrscheinlich es ist, dass die Steigung der Geraden mindestens so groß ist, wie sie durch die Methode der kleinsten Quadrate berechnet wurde. Die Mathematik dahinter ist hier beschrieben (TODO).\nLiegt der p-Wert unter 0,05, dann sagt man, dass der Effekt von \\(x\\) auf \\(y\\) signifikant ist. In diesem Fall ist der p-Wert deutlich unter 0,05. Daher können wir annehmen, dass es einen Effekt von \\(x\\) auf \\(y\\) gibt.\nÄndern wir unsere Daten so, dass die Datenpunkte deutlich weiter um die Gerade herum gestreut sind:\n\nset.seed(1)\n\nx &lt;- rnorm(n = 100, mean = 3, sd = 1)\nfehler &lt;- rnorm(n = 100, mean = 0, sd = 5) # Der Fehler wird größer\ny &lt;- 1/3 * x + fehler\n\nqplot(x, y) +\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nausgleichsgerade &lt;- lm(y ~ x)\n\nausgleichsgerade %&gt;% \n  summary()\n\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-9.3842 -3.0688 -0.6975  2.6970 11.7309 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)  -0.1726     1.7424  -0.099    0.921\nx             0.3280     0.5386   0.609    0.544\n\nResidual standard error: 4.814 on 98 degrees of freedom\nMultiple R-squared:  0.00377,   Adjusted R-squared:  -0.006395 \nF-statistic: 0.3709 on 1 and 98 DF,  p-value: 0.5439\n\n\nIn diesem Fall liegt der p-Wert bei 0,544, was deutlich über 0,05 ist. Wir können also nicht ablehnen, dass es in Wirklichkeit keinen Effekt von \\(x\\) auf \\(y\\) gibt."
  },
  {
    "objectID": "07-2-mathematik-pwert.html",
    "href": "07-2-mathematik-pwert.html",
    "title": "4E2 Herleitung des p-Wertes",
    "section": "",
    "text": "Um zu verstehen, was der p-Wert genau ist und wie er berechnet werden kann, müssen wir uns zunächst mit dem Begriff der Nullhypothese und der Alternativhypothese beschäftigen.\nDie Nullhypothese ist die Annahme, dass es keinen Effekt (von \\(x\\) auf \\(y\\), einer Maßnahme, …) gibt. Die Alternativhypothese ist das Gegenteil, also die Annahme, dass es einen Effekt gibt.\nDas bedeutet, unter der Nullhypothese nehmen wir an, dass in unserem Modell\n\\[\ny = a + bx\n\\]\n\\(b=0\\) ist. Wir können dann die Abweichung des geschätzten Wertes für \\(b\\) von 0 berechnen und nennen diese Statistik t-Statistik:\n\\[\nt = \\frac{b-0}{s/\\sqrt{N}}\n\\]\n\\(s\\) ist hier die Standardabweichung von \\(x\\) und \\(N\\) die Anzahl der Datenpunkte.\nDen p-Wert können wir nun beschreiben als die Wahrscheinlichkeit, dass der Betrag der t-Statistik (also die Abweichung des geschätzten Wertes für \\(b\\) von 0) mindestens so groß ist wie oben berechnet. Grafisch dargestellt sieht das wie folgt aus:\nTODO\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nx_vals &lt;- seq(-4, 4, length = 100)\n\ny_vals &lt;- dnorm(x_vals)\n\ndata &lt;- tibble(x_vals, y_vals)\n\ndata %&gt;% \n  ggplot(aes(x_vals, y_vals)) +\n  geom_line(linewidth = 1, color = \"black\") +\n  theme_classic() +\n  theme(axis.ticks = element_blank(),\n        #axis.text.x = element_blank(),\n        #axis.text.y = element_blank()\n        ) +\n  xlab(\"x\") +\n  ylab(\"y\") +\n  geom_vline(xintercept = 1.5, color = \"red\", linewidth = 1) +\n  geom_vline(xintercept = -1.5, color = \"red\", linewidth = 1) +\n  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.43)) +\n  stat_function(fun = dnorm, \n                xlim = c(1.5, 4),\n                geom = \"area\", \n                fill = \"red\",\n                alpha = 0.3) +\n  stat_function(fun = dnorm, \n                xlim = c(-4, -1.5),\n                geom = \"area\", \n                fill = \"red\",\n                alpha = 0.3) +\n  annotate(\"text\", x=-1.65, y=0.2, label=\"t\", angle=90)"
  }
]