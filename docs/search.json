[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Willkommen!",
    "section": "",
    "text": "Dies ist die Seite zu meiner Data Science-AG, die ich von Januar bis Juni 2024 halten möchte. Auf dieser Seite werden nach und nach R-Skripte entstehen, die jeweils in den AG-Stunden erstellt werden."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#anfang",
    "href": "index.html#anfang",
    "title": "Start in R",
    "section": "",
    "text": "Wir starten einfach.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#mitte",
    "href": "index.html#mitte",
    "title": "Start in R",
    "section": "Mitte",
    "text": "Mitte\n\nCode\nNoch etwas Code.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\n\nErklärung\nHier könnte Ihre Erklärung stehen."
  },
  {
    "objectID": "index.html#ende",
    "href": "index.html#ende",
    "title": "Start in R",
    "section": "Ende",
    "text": "Ende\nDas ist das Ende."
  },
  {
    "objectID": "01-einfuehrung.html",
    "href": "01-einfuehrung.html",
    "title": "Installation",
    "section": "",
    "text": "Was nötig ist, um mit R arbeiten zu können, hängt davon ab, welches Betriebssystem auf eurem Gerät installiert ist."
  },
  {
    "objectID": "index.html#ablauf",
    "href": "index.html#ablauf",
    "title": "Willkommen!",
    "section": "Ablauf",
    "text": "Ablauf\n\nUnter “Einführung in R” finden sich Anleitungen, die die Einrichtung von R erklären und den Aufbau der Software “RStudio” erläutern. Zudem behandeln wir dort die ersten Schritte im Programmieren mit R.\nDas erste Treffen findet voraussichtlich am 12. Januar 2024 im GaW statt. Der Raum wird noch bekannt gegeben.\nMathematikkenntnisse bis zur EF sind erforderlich. Programmierkenntnisse sind nicht vonnöten."
  },
  {
    "objectID": "01-einfuehrung.html#installation",
    "href": "01-einfuehrung.html#installation",
    "title": "Einführung in R",
    "section": "",
    "text": "Was nötig ist, um mit R arbeiten zu können, hängt davon ab, welches Betriebssystem auf eurem Gerät installiert ist.\n\n\nAuf Windows und MacOS müssen wir zwei Programme installieren: zum einen die R-Distribution (das heißt, das Paket, mit dem man R-Code ausführen kann), zum anderen eine Entwicklungsumgebung, in der wir unseren R-Code schreiben können und die uns zahlreiche Hilfsmittel zum Schreiben unseres Codes und zum Anzeigen unserer Ergebnisse bietet.\nIn den vergangenen Jahren habe ich einige verschiedene ausprobiert, aber ich bin am Ende immer zu der bekanntesten Software für R zurückgekehrt, nämlich RStudio. RStudio ist eine von der Firma Posit entwickelte grafische Oberfläche, mit der ihr euren R-Code strukturiert schreiben und die Ergebnisse eurer Analyse ansprechend aufbereiten könnt. Natürlich könnt ihr auch andere Programme ausprobieren und benutzen, aber die weiteren Erklärungen sind auf RStudio ausgerichtet.\n\nR-Distribution\nR ist eine frei verfügbare Software und kann somit von jedem kostenlos heruntergeladen werden.\nIhr könnt sie installieren, indem ihr die Seite cran.r-project.org aufruft und dort auf den Link Download R for MacOS bzw. Download R for Windows klickt. Wenn ihr ein MacBook habt, wählt ihr auf dieser Seite die passende Version für euer Gerät aus. Bei Windows klicken wir auf base und dann auf den Downloadlink ganz oben.\nIhr folgt dann den Installationsanweisungen, dabei könnt ihr alles bei den Standardeinstellungen belassen.\nEntwicklungsumgebung\nDamit wir die R-Distribution sinnvoll nutzen können, benötigen wir eine Entwicklungsumgebung, in unserem Fall RStudio.\nUm RStudio zu installieren, geht auf die Seite posit.co/download/rstudio-desktop. Dort seht ihr den Punkt 2: Install RStudio. Es sollte bereits das richtige Betriebssystem vorgewählt sein, ansonsten finden sich darunter noch weitere Installer. Ladet nun durch Klick auf den Button Download RStudio for … das Installationsprogramm herunter und folgt den Installationsanweisungen.\n\nNun sollten sowohl R als auch RStudio auf eurem Gerät installiert sein."
  },
  {
    "objectID": "01-einfuehrung.html#ipads-and-android-tablets",
    "href": "01-einfuehrung.html#ipads-and-android-tablets",
    "title": "Einführung in R",
    "section": "iPads and Android tablets",
    "text": "iPads and Android tablets\nUnder construction."
  },
  {
    "objectID": "01-einfuehrung.html#ipads-und-android-tablets",
    "href": "01-einfuehrung.html#ipads-und-android-tablets",
    "title": "Installation",
    "section": "iPads und Android-Tablets",
    "text": "iPads und Android-Tablets\nAuch auf einem iPad oder einem Android-Tablet kann man mit R programmieren, auch wenn das ohne Tastatur und Maus wahrscheinlich schwierig ist. Sollte es so sein, dass ihr keinen Zugang zu einem Laptop habt, ist dies jedoch eine mögliche Lösung:\nWir installieren kein Programm auf unserem Gerät. Stattdessen erstellen wir ein Benutzerkonto bei Posit, dem Anbieter von RStudio. Auf diese Weise können wir, wenn auch nur mit beschränkter Rechenzeit, in unserem Browser programmieren. Hierzu geht ihr auf die Seite von Posit, posit.cloud, und klickt dort auf Get started. Wählt den kostenlosen Plan (Cloud Free) aus und registriert euch dann unter Sign up. Wenn das geklappt hat, solltet ihr bereit sein, um in R zu programmieren."
  },
  {
    "objectID": "01-einfuehrung.html#linux",
    "href": "01-einfuehrung.html#linux",
    "title": "Installation",
    "section": "Linux",
    "text": "Linux\nSolltet ihr eine Linux-Distribution auf eurem Laptop installiert haben, dann findet ihr auf YouTube sowie mit einer kurzen Internetrecherche zahlreiche Anleitungen, wie ihr R auf eurer Plattform installieren könnt. Ich gehe nicht näher auf diesen Fall ein, da man je nach Distribution unterschiedlich verfahren muss und ich dem geneigten Linux-Nutzer unterstelle, selbst in der Lage zu sein, die Installation durchzuführen."
  },
  {
    "objectID": "01-einfuehrung.html#windows-und-macos",
    "href": "01-einfuehrung.html#windows-und-macos",
    "title": "Installation",
    "section": "Windows und MacOS",
    "text": "Windows und MacOS\nAuf Windows und MacOS müssen wir zwei Programme installieren: zum einen die R-Distribution (das heißt, das Paket, mit dem man R-Code ausführen kann), zum anderen eine Entwicklungsumgebung, in der wir unseren R-Code schreiben können und die uns zahlreiche Hilfsmittel zum Schreiben unseres Codes und zum Anzeigen unserer Ergebnisse bietet.\nIn den vergangenen Jahren habe ich einige verschiedene ausprobiert, aber ich bin am Ende immer zu der bekanntesten Software für R zurückgekehrt, nämlich RStudio. RStudio ist eine von der Firma Posit entwickelte grafische Oberfläche, mit der ihr euren R-Code strukturiert schreiben und die Ergebnisse eurer Analyse ansprechend aufbereiten könnt. Natürlich könnt ihr auch andere Programme ausprobieren und benutzen, aber die weiteren Erklärungen sind auf RStudio ausgerichtet.\n\nR-Distribution\nR ist eine frei verfügbare Software und kann somit von jedem kostenlos heruntergeladen werden.\nIhr könnt sie installieren, indem ihr die Seite cran.r-project.org aufruft und dort auf den Link Download R for MacOS bzw. Download R for Windows klickt. Wenn ihr ein MacBook habt, wählt ihr auf dieser Seite die passende Version für euer Gerät aus. Bei Windows klicken wir auf base und dann auf den Downloadlink ganz oben.\nIhr folgt dann den Installationsanweisungen, dabei könnt ihr alles bei den Standardeinstellungen belassen.\nEntwicklungsumgebung\nDamit wir die R-Distribution sinnvoll nutzen können, benötigen wir eine Entwicklungsumgebung, in unserem Fall RStudio.\nUm RStudio zu installieren, geht auf die Seite posit.co/download/rstudio-desktop. Dort seht ihr den Punkt 2: Install RStudio. Es sollte bereits das richtige Betriebssystem vorgewählt sein, ansonsten finden sich darunter noch weitere Installer. Ladet nun durch Klick auf den Button Download RStudio for … das Installationsprogramm herunter und folgt den Installationsanweisungen.\n\nNun sollten sowohl R als auch RStudio auf eurem Gerät installiert sein."
  },
  {
    "objectID": "01-installation.html",
    "href": "01-installation.html",
    "title": "1.1 Installation",
    "section": "",
    "text": "Was nötig ist, um mit R arbeiten zu können, hängt davon ab, welches Betriebssystem auf eurem Gerät installiert ist."
  },
  {
    "objectID": "01-installation.html#windows-und-macos",
    "href": "01-installation.html#windows-und-macos",
    "title": "1.1 Installation",
    "section": "Windows und MacOS",
    "text": "Windows und MacOS\nAuf Windows und MacOS müssen wir zwei Programme installieren: zum einen die R-Distribution (das heißt, das Paket, mit dem man R-Code ausführen kann), zum anderen eine Entwicklungsumgebung, in der wir unseren R-Code schreiben können und die uns zahlreiche Hilfsmittel zum Schreiben unseres Codes und zum Anzeigen unserer Ergebnisse bietet.\nIn den vergangenen Jahren habe ich einige verschiedene ausprobiert, aber ich bin am Ende immer zu der bekanntesten Software für R zurückgekehrt, nämlich RStudio. RStudio ist eine von der Firma Posit entwickelte grafische Oberfläche, mit der ihr euren R-Code strukturiert schreiben und die Ergebnisse eurer Analyse ansprechend aufbereiten könnt. Natürlich könnt ihr auch andere Programme ausprobieren und benutzen, aber die weiteren Erklärungen sind auf RStudio ausgerichtet.\n\nR-Distribution\nR ist eine frei verfügbare Software und kann somit von jedem kostenlos heruntergeladen werden.\nIhr könnt sie installieren, indem ihr die Seite cran.r-project.org aufruft und dort auf den Link Download R for MacOS bzw. Download R for Windows klickt. Wenn ihr ein MacBook habt, wählt ihr auf dieser Seite die passende Version für euer Gerät aus. Bei Windows klicken wir auf base und dann auf den Downloadlink ganz oben.\nFolgt dann den Installationsanweisungen, dabei könnt ihr alles bei den Standardeinstellungen belassen.\nEntwicklungsumgebung\nDamit wir die R-Distribution sinnvoll nutzen können, benötigen wir eine Entwicklungsumgebung, in unserem Fall RStudio.\nUm RStudio zu installieren, geht auf die Seite posit.co/download/rstudio-desktop. Dort seht ihr den Punkt 2: Install RStudio. Es sollte bereits das richtige Betriebssystem vorgewählt sein, ansonsten finden sich darunter noch weitere Installer. Ladet nun durch Klick auf den Button Download RStudio for … das Installationsprogramm herunter und folgt den Installationsanweisungen.\n\nNun sollten sowohl R als auch RStudio auf eurem Gerät installiert sein."
  },
  {
    "objectID": "01-installation.html#ipads-und-android-tablets",
    "href": "01-installation.html#ipads-und-android-tablets",
    "title": "1.1 Installation",
    "section": "iPads und Android-Tablets",
    "text": "iPads und Android-Tablets\nAuch auf einem iPad oder einem Android-Tablet kann man mit R programmieren, auch wenn das ohne Tastatur und Maus wahrscheinlich schwierig ist. Sollte es so sein, dass ihr keinen Zugang zu einem Laptop habt, ist dies jedoch eine mögliche Lösung:\nWir installieren kein Programm auf unserem Gerät. Stattdessen erstellen wir ein Benutzerkonto bei Posit, dem Anbieter von RStudio. Auf diese Weise können wir, wenn auch nur mit beschränkter Rechenzeit, in unserem Browser programmieren. Hierzu geht ihr auf die Seite von Posit, posit.cloud, und klickt dort auf Get started. Wählt den kostenlosen Plan (Cloud Free) aus und registriert euch dann unter Sign up. Wenn das geklappt hat, solltet ihr bereit sein, um in R zu programmieren."
  },
  {
    "objectID": "01-installation.html#linux",
    "href": "01-installation.html#linux",
    "title": "1.1 Installation",
    "section": "Linux",
    "text": "Linux\nSolltet ihr eine Linux-Distribution auf eurem Laptop installiert haben, dann findet ihr auf YouTube sowie mit einer kurzen Internetrecherche zahlreiche Anleitungen, wie ihr R auf eurer Plattform installieren könnt. Ich gehe nicht näher auf diesen Fall ein, da man je nach Distribution unterschiedlich verfahren muss und ich dem geneigten Linux-Nutzer unterstelle, selbst in der Lage zu sein, die Installation durchzuführen."
  },
  {
    "objectID": "02-erste-schritte.html#skripte-erstellen",
    "href": "02-erste-schritte.html#skripte-erstellen",
    "title": "1.2 Erste Schritte in RStudio",
    "section": "Skripte erstellen",
    "text": "Skripte erstellen"
  },
  {
    "objectID": "02-erste-schritte.html#pakete",
    "href": "02-erste-schritte.html#pakete",
    "title": "1.2 Erste Schritte in RStudio",
    "section": "Pakete",
    "text": "Pakete\nUnder construction."
  },
  {
    "objectID": "02-erste-schritte.html#packages",
    "href": "02-erste-schritte.html#packages",
    "title": "1.2 Erste Schritte in RStudio",
    "section": "Packages",
    "text": "Packages\n\n\nDer Code, der im Video verwendet wurde:\n\nlibrary(ggplot2)\n\nmtcars\n\nggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  geom_smooth(method = lm)"
  },
  {
    "objectID": "02-erste-schritte.html",
    "href": "02-erste-schritte.html",
    "title": "1.2 Erste Schritte in RStudio",
    "section": "",
    "text": "Auf dieser Seite findet ihr drei Videos, die euch mit den Grundfunktionen von R und RStudio vertraut machen sollen."
  },
  {
    "objectID": "02-erste-schritte.html#hauptfenster-und-konsole",
    "href": "02-erste-schritte.html#hauptfenster-und-konsole",
    "title": "1.2 Erste Schritte in RStudio",
    "section": "Hauptfenster und Konsole",
    "text": "Hauptfenster und Konsole"
  },
  {
    "objectID": "index.html#zielsetzung",
    "href": "index.html#zielsetzung",
    "title": "Willkommen!",
    "section": "Zielsetzung",
    "text": "Zielsetzung\nDas Ziel dieser AG ist es, mithilfe der statistischen Programmiersprache R interessante Fragestellungen zu beantworten. Dabei sollen die Schülerinnen und Schüler einerseits lernen, in R zu programmieren und diese Fähigkeit auf reale Datensätze anwenden, andererseits Methoden und Ergebnisse kritisch zu hinterfragen und somit zu neuen, datenbasierten Erkenntnissen gelangen."
  },
  {
    "objectID": "praesentation_ag.html",
    "href": "praesentation_ag.html",
    "title": "Data Science-AG",
    "section": "",
    "text": "Data Science-AG\n\n\nWas machen wir?\n\nDatenanalyse\nDazu brauchen wir zwei Dinge:\n\nDaten\nEine Programmiersprache (R)\n\n\n\n\n\n\nWelche Daten?\n\nWetterdaten vom DWD\nDatensätze von Kaggle\n\nTestergebnisse von Schulen (USA)\nEuropean Social Survey (EU)\nImmobilieninserate (D)\n\n\n\n\n\nWelche Daten?\n\nDatensätze von Kaggle\n\nPew Research Center-Befragungen (USA)\nCoronadaten (D/EU)\n\n\n\n\nDaten zu ESC-Teilnehmersongs (GitHub)\nund viele mehr\n\n\n\nWieso R?\n\nStatistische Programmiersprache\nzahlreiche Packages\nim akademischen Bereich häufig genutzt\nOpen-Source\nHandhabe von Daten (“Data Wrangling”) deutlich einfacher als in Python\n\n\n\nWas jetzt?\n\nWebsite für die AG ist bereits verfügbar\nPlan: Start nach den Weihnachtsferien\nEigene Projekte am Ende des Schuljahres"
  },
  {
    "objectID": "03-datenstrukturen.html",
    "href": "03-datenstrukturen.html",
    "title": "2.1 Datentypen und Datenstrukturen",
    "section": "",
    "text": "Nachdem wir uns mit RStudio vertraut gemacht haben, kommen wir nun zur ersten wirklichen inhaltlichen Auseinandersetzung mit R, nämlich mit Datentypen und Datenstrukturen. Wir wollen verstehen, welche es gibt und wie diese funktionieren, um sie in unserer Datenanalyse später benutzen zu können."
  },
  {
    "objectID": "03-datenstrukturen.html#datentypen",
    "href": "03-datenstrukturen.html#datentypen",
    "title": "2.1 Datentypen und Datenstrukturen",
    "section": "Datentypen",
    "text": "Datentypen\nNumeric\nDer Datentyp numeric beinhaltet alle reellen Zahlen. Zusätzlich werden alle ganzen Zahlen standardmäßig als numeric klassifiziert.\nDies können wir im folgenden Beispiel sehen:\n\nganzzahl &lt;- 1\ndezimalzahl &lt;- 1.0\n\nclass(ganzzahl)\n\n[1] \"numeric\"\n\nclass(dezimalzahl)\n\n[1] \"numeric\"\n\nganzzahl == dezimalzahl\n\n[1] TRUE\n\n\nCharacter\nDer Datentyp character beschreibt Wörter, Sätze; alles, was man mit Zahlen und Buchstaben zusammenfügen kann.\n\ntext &lt;- \"Wir lernen R.\"\n\nclass(text)\n\n[1] \"character\"\n\ntext_kopie &lt;- \"Wir lernen R.\"\n\ntext == text_kopie\n\n[1] TRUE\n\n\nLogical\nDer Datentyp logical beinhaltet die Werte TRUE und FALSE (wahr und falsch). Sie können auch mit T und F abgekürzt werden. Man kann mit TRUE und FALSE auch rechnen, TRUE hat hierbei den Wert 1, FALSE den Wert 0.\n\nwahr &lt;- TRUE\nfalsch &lt;- FALSE\n\nwahr_kurz &lt;- T\nfalsch_kurz &lt;- F\n\nwahr == wahr_kurz\n\n[1] TRUE\n\nfalsch == falsch_kurz\n\n[1] TRUE\n\nwahr + falsch\n\n[1] 1\n\n\nWeniger wichtige Datentypen\nInteger\nDer Datentyp integer enthält alle ganzen Zahlen. Integer werden mit einem L hinter der Zahl gekennzeichnet.\n\nganzzahl &lt;- 1L\n\nclass(ganzzahl)\n\n[1] \"integer\"\n\nandere_ganzzahl &lt;- 2L\n\nsumme &lt;- ganzzahl + andere_ganzzahl\n\nclass(summe)\n\n[1] \"integer\"\n\n# In der Konsole wird das 'L' nicht mit ausgegeben!\nganzzahl\n\n[1] 1\n\n\nComplex\nDieser Datentyp beinhaltet alle komplexen Zahlen.\n\nkomplexe_zahl &lt;- 1i + 1\n\nclass(komplexe_zahl)\n\n[1] \"complex\"\n\nandere_komplexe_zahl &lt;- 9i + 3\n\nkomplexe_zahl + andere_komplexe_zahl\n\n[1] 4+10i"
  },
  {
    "objectID": "03-datenstrukturen.html#datenstrukturen",
    "href": "03-datenstrukturen.html#datenstrukturen",
    "title": "2.1 Datentypen und Datenstrukturen",
    "section": "Datenstrukturen",
    "text": "Datenstrukturen\nWir können mit Variablen aus den oben angegebenen Datentypen sehr gut einfache Rechnungen und Vergleiche durchführen. Um aber effizient zu arbeiten und unsere Daten zu verwalten, braucht es Strukturen, in denen wir Variablen speichern und modifizieren können.\nVektor\nDie wohl wichtigste Datenstruktur in R ist der Vektor. Vektoren sind Ansammlungen von Variablen eines bestimmten Datentyps. Ein Beispiel ist der Vektor \\(\\vec{x}=\\begin{pmatrix}1 \\\\ 2 \\\\ 3\\end{pmatrix}\\), der die Zahlen 1, 2, und 3 enthält.\nWir erstellen oder initialisieren einen Vektor mit der c()-Funktion:\n\n# Vektor initialisieren\nx &lt;- c(1, 2, 3)\n\n# Vektor ausgeben\nx\n\n[1] 1 2 3\n\n\nWenn wir auf Elemente im Vektor zugreifen wollen, dann machen wir das durch eckige Klammern hinter dem Namen des Vektors:\n\n# R beginnt bei der Zählung mit der 1.\nx[1]        # 1. Element\n\n[1] 1\n\nx[-1]       # alle außer dem 1. Element\n\n[1] 2 3\n\nx[1:2]      # alle Elemente vom 1. bis zum 2.\n\n[1] 1 2\n\nx[c(1, 3)]  # alle Elemente, deren Index im Vektor (1,3) enthalten ist\n\n[1] 1 3\n\n\nWir können mit Vektoren ganz normal rechnen (Zeile für Zeile):\n\nx * 3\n\n[1] 3 6 9\n\n# Neuer Vektor\ny &lt;- c(3, 4, 5)\n\n# Zeilenweise Addition/Subtraktion\nx + y\n\n[1] 4 6 8\n\nx - y\n\n[1] -2 -2 -2\n\n# Für alle, die schon Vektoren behandelt haben:\n# Betrag eines Vektors\n# type = \"2\" steht für die sogenannte \"2-Norm\" (die euklidische Norm)\nnorm(x, type = \"2\")\n\n[1] 3.741657\n\n\nWir können verschiedene “Maße” des Vektors nehmen:\n\nlength(x)   # Dimension oder \"Länge\" des Vektors\n\n[1] 3\n\nmean(x)     # Mittelwert des Vektors\n\n[1] 2\n\nsum(x)      # Summe der Einträge des Vektors\n\n[1] 6\n\n\nAufgabe 1\nGib den kleinsten und den größten Eintrag sowie den Median von x an!\n\nLösungmin(x)\nmax(x)\nmedian(x)\n\n\nDataframe und Tibble\nFür diesen Teil und auch darüber hinaus benötigen wir die tidyverse-Library. Es bietet zahlreiche nützliche Features, die uns beim Codeschreiben viel Arbeit abnehmen und unseren Code besser lesbar machen werden.\nWenn ihr diese Library noch nicht installiert habt, dann geht das mit dem folgenden Befehl in eurer Konsole:\n\ninstall.packages(\"tidyverse\")\n\nWir laden nun die tidyverse-Library in unseren Arbeitsbereich, indem wir folgenden Code benutzen:\n\nlibrary(tidyverse)\n\nDataframes bzw. Tibbles sind ähnlich wie Tabellen: Sie speichern geordnet Daten. Dabei sind in den Zeilen die verschiedenen Einträge angeordnet, und in den Spalten finden sich Variablen für jeden dieser Einträge.\nWir rufen nun das mtcars-Datenset auf, eines der bekanntesten Datensets in R, auf das auch ohne weitere Pakete direkt zugegriffen werden kann. Das mtcars-Datenset enthält Daten zu einigen (älteren) Autos. Die Beschreibung dieses Datensets finden wir, indem wir ?mtcars in die Konsole eingeben.\n\n# Um nur die obersten Einträge eines Datensets auszugeben,\n# benutzen wir die head()-Funktion\nhead(mtcars)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nWir erhalten eine Übersicht über die ersten Autos und ihre Spezifikationen. Doch wie wir im Einführungskapitel gesehen haben, ist das nicht das Einzige, was wir mit Dataframes oder Tibbles machen können.\nWir wollen nun alle Autos mit mehr als 30 Meilen pro Gallone Benzin ausgeben. Hierbei können wir mit dem Dollarzeichen auf einzelne Spalten zugreifen, und ähnlich wie bei Vektoren benutzen wir eckige Klammern, um auf einzelne Elemente zuzugreifen. Die Schreibweise hierbei ist wie folgt: Datenset[Bedingung für Zeilen, Bedingung für Spalten]. Da wir hier die Zeilen (Autos) mit mehr als 30 Meilen pro Gallone ausgeben wollen, füllen wir diese Bedingung in die Bedingung für Zeilen ein und erhalten das gewünschte Ergebnis.\n\nmtcars[mtcars$mpg &gt; 30, ]\n\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1\nLotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2\n\n\nDas ist aber bei mehreren Bedingungen, oder wenn wir diesen Filter in eine Folge aus Operationen einbinden wollen, ziemlich schwer zu schreiben und vor allem zu lesen. Deswegen überführen wir dieses Datenset mit der as_tibble()-Funktion in einen Tibble, auf dem wir viel einfacher filtern und später auch Daten entfernen, zusammenfügen usw. können. Für diese Funktion muss nun das tidyverse-Paket installiert sein (s.o.).\n\nmtcars_tibble &lt;- as_tibble(mtcars)\n\nSchauen wir uns diesen Tibble mal an:\n\nmtcars_tibble\n\n# A tibble: 32 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# ℹ 22 more rows\n\n\nKomisch, die Autonamen sind weg! Das liegt daran, dass Tibbles etwas anders funktionieren als Dataframes. Dataframes haben benannte Zeilen, während Tibbles an sich diese Information nicht speichern. Wir müssen daher Folgendes machen:\n\nmtcars_tibble &lt;- as_tibble(rownames_to_column(mtcars))\n\nmtcars_tibble\n\n# A tibble: 32 × 12\n   rowname       mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 Mazda RX4    21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2 Mazda RX4 …  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3 Datsun 710   22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4 Hornet 4 D…  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5 Hornet Spo…  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6 Valiant      18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7 Duster 360   14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8 Merc 240D    24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9 Merc 230     22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10 Merc 280     19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# ℹ 22 more rows\n\n\nViel besser. Mit diesem Tibble können wir nun viel einfacher filtern, nämlich mit der filter()-Funktion:\n\nfilter(mtcars_tibble, mpg &gt; 30)\n\n# A tibble: 4 × 12\n  rowname        mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Fiat 128      32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1\n2 Honda Civic   30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2\n3 Toyota Coro…  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1\n4 Lotus Europa  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2\n\n\nOben haben wir schon gesehen, dass wir zum Umformen des Dataframes in einen Tibble mehrere Schritte ineinander bauen müssen. Wollen wir nun noch den ursprünglichen Dataframe vor der Umformung verändern, kann das ziemlich schnell unübersichtlich werden:\n\n# Wir wollen z.B. in einem Schritt den Dataframe in einen Tibble umwandeln und dann filtern:\nfilter(as_tibble(rownames_to_column(mtcars)), mpg &gt; 30)\n\n# A tibble: 4 × 12\n  rowname        mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Fiat 128      32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1\n2 Honda Civic   30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2\n3 Toyota Coro…  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1\n4 Lotus Europa  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2\n\n# Unübersichtlich und fehleranfällig!\n\nStattdessen führen wir den sogenannten Pipe-Operator (geschrieben %&gt;%) als neue Schreibweise ein. Man kann sich seine Funktion so vorstellen, dass er alles, was auf der linken Seite von ihm steht, nimmt und dem, was auf der rechten Seite steht, übergibt. Wir wollen den vorherigen Codeblock einfacher schreiben:\n\n# Lesen von links nach rechts:\nmtcars %&gt;%                     # Wir nehmen das mtcars-Datenset...\n  rownames_to_column() %&gt;%     # und lagern die Namen in eine eigene Spalte aus...\n  as_tibble() %&gt;%              # und konvertieren das in einen Tibble...\n  filter(mpg &gt; 30)             # und filtern nach Autos, die mehr als 30 MPG haben.\n\n# A tibble: 4 × 12\n  rowname        mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Fiat 128      32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1\n2 Honda Civic   30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2\n3 Toyota Coro…  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1\n4 Lotus Europa  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2\n\n\nViel einfacher lesbar, oder? Wir werden diese Datenstruktur sehr häufig nutzen, eben weil wir diese Funktionen anwenden können.\nAufgabe 2\nWähle alle außer den ersten 15 Autos aus (?slice in die Konsole einzugeben könnte hilfreich sein, schaue dort nach einem Weg, Zeilen auszuschließen) und filtere dann nach den Autos mit mindestens 6 Zylindern. Sortiere dann die Autos nach Meilen pro Gallone (absteigend; ?arrange könnte hilfreich sein, schaue dort unter den Beispielen nach einem Weg, absteigend zu sortieren). Zeige nur die Namen der Autos, die Meilen pro Gallone, die Zylinder und die PS an (?select könnte hilfreich sein).\n\nLösungmtcars_tibble %&gt;%                  # Tibble auswählen\n  slice(-(1:15)) %&gt;%               # Alle außer den ersten 15 Zeilen auswählen\n  filter(cyl &gt;= 6) %&gt;%             # Alle Autos mit mindestens 6 Zylindern\n  arrange(desc(mpg)) %&gt;%           # Autos nach Meilen pro Gallone sortieren\n  select(rowname, mpg, cyl, hp)    # Nur Name, MPG, Zylinder, PS anzeigen\n\n\nAufgabe 3\nNew York gehört mit seinen Flughäfen zu den weltweit bekanntesten Verkehrsdrehkreuzen. Es ist so bekannt, dass es in R eine eigene Library für die Aufzeichnung aller abgehenden Flüge im Jahr 2013 gibt.\nInstalliere für diese Aufgabe die nycflights13-Library und lade sie in den Arbeitsbereich. Uns interessiert vor allem der flights-Tibble.\n\nWelche Flüge sind verfrüht abgehoben?\nWelche Flüge sind verspätet abgehoben und haben die Verspätung aufgeholt?\nFüge eine neue Variable short_flight zum Tibble hinzu, die den Wert 1 annimmt, wenn der Flug weniger als 2 Stunden Flugzeit hat, und ansonsten 0 ist (Hinweis: ?mutate könnte hilfreich sein).\nWelcher Anteil an verspätet abgehobenen Flügen, die die Verspätung aufgeholt haben, hatten weniger als zwei Stunden Flugzeit?\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nZu 3.: Nutze nach dem Filtern mutate(... = if_else(...)), um für jeden Flug die Variable short_flight zu erstellen.\nZu 4.: Verwende die Funktionen summarise(), sum() und n(), um den Anteil zu errechnen.\n\n\n\n\nLösunglibrary(nycflights13)\n\n# 1\nflights %&gt;% \n  filter(dep_delay &lt; 0)\n\n# 2\nflights %&gt;% \n  filter(dep_delay &gt; 0 & arr_delay &lt;= 0)\n\n# 3\nflights %&gt;% \n  filter(dep_delay &gt; 0 & arr_delay &lt;= 0) %&gt;% \n  mutate(short_flight = if_else(air_time &lt; 120, 1, 0)) \n\n# 4\nflights %&gt;% \n  filter(dep_delay &gt; 0 & arr_delay &lt;= 0) %&gt;% \n  mutate(short_flight = if_else(air_time &lt; 120, 1, 0)) %&gt;% \n  summarise(share_short = sum(short_flight)/n())\n\n\nListe\nInfo: Dieses Kapitel folgt grob den Inhalten aus Kapitel 9 in “Beginning Computer Science with R” von Homer White.\nDie Datenstrukturen, die wir uns bisher angeschaut haben, waren atomisch, das heißt, sie können pro Einheit (bspw. Spalte) nur eine Art Datentyp beinhalten. Nun gehen wir über zu den Listen, die Objekte aller Arten beinhalten können. Zahlen, Wörter, andere Listen, alles ist möglich.\nWir beginnen die Erkundung, indem wir mit list() selbst Listen erstellen.\n\nliste1 &lt;- list(\n  modellname = \"Audi A6\",\n  zulassung = as_date(\"15.05.2013\", format = \"%d.%m.%Y\"),\n  kilometerstand = 115290\n)\n\ntibble1 &lt;- tibble(\n  x = length(letters),\n  y = letters\n)\n\nliste2 &lt;- list(\n  auto = liste1,\n  buchstaben = tibble1\n)\n\nliste3 &lt;- list(\n  vokale = c(\"a\", \"e\", \"i\", \"o\", \"u\"),\n  listen = list(liste1, liste2)\n)\n\nDie hier zu sehenden Listen beinhalten Objekte unterschiedlicher Art, und sie können wiederum Listen enthalten. Wir lassen uns nun Liste 1 ausgeben:\n\nliste1\n\n$modellname\n[1] \"Audi A6\"\n\n$zulassung\n[1] \"2013-05-15\"\n\n$kilometerstand\n[1] 115290\n\n\nWir sehen, dass jedes Element dieser Liste einen Namen (z.B. $modellname) hat. Man kann die Elemente dementsprechend auch über ihren Namen aufrufen:\n\nliste1$modellname\n\n[1] \"Audi A6\"\n\n\nWir schon bei Eingabe des Dollarzeichens Gebrauch von der Autovervollständigung machen: Die Elemente der Liste werden uns sofort angezeigt.\nLeere Listen können auch erstellt werden, zum Beispiel, wenn wir noch nicht wissen, wie viele Elemente welcher Art gesammelt werden sollen:\n\nleere_liste &lt;- list()\n\nWissen wir hingegen, wie viele Elemente wir speichern wollen, können wir folgende Schreibweise verwenden:\n\nliste &lt;- vector(mode = \"list\", length = 5) # 5 durch gewünschte Länge ersetzen\n\nAufgabe 4\nErstelle eine Liste uebe_liste mit den folgenden drei Elementen:\n\nAlle geraden Zahlen von 2 bis 123 (Name: gerade_zahlen)\nAlle großen Buchstaben (Name: alphabet_gross)\nDie Billboard Top 100 aus dem Jahr 2000 (Zu finden unter billboard, Name: top100)\n\n\n\n\n\n\n\nTipp\n\n\n\n\n\nEine Abfolge von Zahlen mit einem bestimmten Abstand kann mit seq() erzeugt werden.\n\n\n\n\nLösunguebe_liste &lt;- list(\n  gerade_zahlen = seq(2, 123, by = 2),\n  alphabet_gross = LETTERS,\n  top100 = billboard\n)\n\n\nAufgabe 5\nWas passiert, wenn wir nach dem Erstellen der Liste aus Aufgabe 4 folgenden Code ausführst?\n\nuebe_liste &lt;- c(uebe_liste, list(zahl = 5))\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\nDie Liste uebe_liste wird erweitert mit dem Element zahl.\n\n\n\nOperationen auf Listen\nWollen wir auf einen Teil der Liste zugreifen, so können wir das genau wie bei Vektoren mit folgendermaßen machen:\n\nliste1[1:2] # Gibt die ersten beiden Elemente der Liste (modellname, zulassung)\n\n$modellname\n[1] \"Audi A6\"\n\n$zulassung\n[1] \"2013-05-15\"\n\n\nWir können auch auf genau ein Element der Liste zugreifen:\n\nvokale &lt;- liste3[1]\n\nNehmen wir nun an, wir wollen den vierten Vokal aus vokale ausgeben. Versuchen wir es wie folgt:\n\nvokale[4]\n\n$&lt;NA&gt;\nNULL\n\n\nerhalten wir die Ausgabe $&lt;NA&gt; NULL. Das liegt daran, dass beim Zugreifen auf eine Liste mit einer einfachen eckigen Klammer ([...]) eine Liste mit genau den entsprechenden Inhalten zurückgegeben wird. In unserem Fall ist das eine Liste mit einem Element:\n\nlength(vokale)\n\n[1] 1\n\n\nVersuchen wir nun, auf das vierte Element (in dem Fall der Liste) zuzugreifen, funktioniert das nicht, weil die zurückgegebene Liste eben nur ein Element hat.\nWenn wir das Element selbst (und nicht eine Liste bestehend aus diesem Element) zurückgeben wollen, müssen wir doppelte eckige Klammern ([[...]]) benutzen:\n\nvokale &lt;- liste3[[1]]\n\nvokale[4]\n\n[1] \"o\""
  },
  {
    "objectID": "04-funktionen-und-schleifen.html",
    "href": "04-funktionen-und-schleifen.html",
    "title": "2.2 Schleifen und Funktionen",
    "section": "",
    "text": "Wir werden zwei wichtige Konzepte behandeln - Funktionen und Schleifen. Mit Funktionen können wir einen Code in einen Block auslagern, ihn benennen und wiederbenutzen. Mit Schleifen können wir Code ausführen, bis eine bestimmte Bedingung erfüllt ist.\nSchleifen\n\n# Was macht diese Schleife?\n# (1) Sie definiert die Variable i. Diese Variable nimmt alle Werte von 1 bis 10 an\n# (sie \"iteriert\" über die Zahlen 1 bis 10).\n# (2) Alles, was innerhalb der Schleife steht, kann auf i zugreifen.\n# (3) Im Inneren der Schleife wird der jeweilige Wert von i in die Konsole ausgegeben.\nfor (i in 1:10) {\n  print(i)\n}\n\n\n# Wir können nicht nur über Zahlen iterieren:\nfarben &lt;- c(\"rot\", \"gelb\", \"grün\")\n\n# Es wird das Folgende ausgegeben:\n# Ich mag die Farbe rot\n# Ich mag die Farbe gelb\n# Ich mag die Farbe grün\nfor (farbe in farben) {\n  nachricht &lt;- paste(\"Ich mag die Farbe\", farbe)\n  print(nachricht)\n}\n\nAufgabe 1\nDie Fibonaccifolge ist eine Folge, die mit den Zahlen \\(1, 1, 2, 3, 5, 8, ...\\) beginnt.\n\nWelche Vorschrift beschreibt diese Folge?\nImplementiere die Fibonaccifolge: Schreibe Code, der die ersten 20 Zahlen dieser Folge ausgibt.\n\n\n\n\n\n\n\nLösung 1.\n\n\n\n\n\nDie Vorschrift der Fibonaccifolge lautet \\(F_n=F_{n-1}+F_{n-2}\\).\n\n\n\n\nLösung 2.fib &lt;- rep(NA, 10)\n\nfib[1] &lt;- 1\nfib[2] &lt;- 1\n\nfor (n in 3:length(fib)) {\n  fib[n] &lt;- fib[n-1] + fib[n-2]\n}\n\nfib\n\n\nAufgabe 2\nIllustriere an einem Beispiel, dass folgende Aussage für alle \\(n \\geq 1\\) gilt:\n\\[\nn^2 = \\sum\\limits_{k=1}^n [2k-1]\n\\]\nEs reicht, wenn du beispielsweise alle \\(n \\leq 50\\) betrachtest.\n\n\n\n\n\n\nTipp\n\n\n\n\n\n\\(\\sum\\limits_{k=1}^n [2k-1]\\) kann auch geschrieben werden als \\(1+3+5+...+(2n-1)\\).\n\n\n\n\nLückencode# 2k-1 für 1 &lt;= k &lt;= 50 sind alle ungeraden Zahlen von 1 bis 100.\nx &lt;- seq(from = ..., to = ..., by = ...)\n\n# Wir erstellen einen leeren Vektor y der Länge von x:\ny &lt;- rep(..., length = ...)\n\n# Wir schreiben eine Schleife, die für jedes n &lt;= 50 die Summe von k=1 bis n\n# von 2k-1 berechnet und in y speichert.\nfor (i in 1:length(x)) {\n    y[i] &lt;- sum(...)\n}\n\n# y besteht aus allen Quadratzahlen von 1 bis 50.\ny\n\n\nTODO: map()\nFunktionen\nFunktionen ermöglichen es uns, Code als einen Block zusammenzufassen und wiederzuverwenden. Das ist besonders wichtig, wenn wir immer die gleichen ausgewählten Rechenschritte auf unterschiedlichen Daten durchführen wollen. Gleichzeitig müssen wir den Code nur an einer Stelle umschreiben, wenn wir eine Änderung oder Korrektur vornehmen müssen.\nWir schauen uns im Folgenden eine Abwandlung dieser bayerischen Abituraufgabe an:\n\nEs sei nun \\(X = \\begin{cases} 1 & \\text{Pkw hat Elektromotor} \\\\ 0 & \\text{Pkw hat keinen Elektromotor}\\end{cases}\\) für jedes Auto in der Ziehung. \\(Y\\) ist dann die Zahl der Pkw mit Elektromotor in der Ziehung, also die Summe der Ergebnisse der Ziehung.\nNehmen wir an, es werden von drei Umfrageinstituten jeweils vier dieser Untersuchungen durchgeführt. Die Ergebnisse dieser Umfragen sind in Rohform in der Datei funktionen-ziehungen.csv zu finden.\nAufgabe 3\n\n\nLade die Daten mithilfe der Funktion read_csv() in einen Tibble ziehungen.\n\nLösunglibrary(tidyverse)\n\nziehungen &lt;- \n  read_csv(\"data/funktionen-ziehungen.csv\")\n\n\n\n\nNutze folgenden Codeschnipsel, um aus den gegebenen Daten für \\(X\\ Y\\) zu berechnen. Schlage hierbei mithilfe von ?(Funktion) nach, was diese Funktionen bewirken.\n\ncolnames &lt;- colnames(ziehungen) %&gt;% \n  gsub(\",.*\", \"\", .) %&gt;% \n  unique()\n\nergebnisse &lt;-\n  ziehungen %&gt;% \n  map(sum) %&gt;% \n  matrix(., nrow \n         = 4, ncol = 3, byrow = F,\n         dimnames = list(NULL, colnames)) %&gt;% \n  as_tibble() %&gt;% \n  unnest(cols = all_of(colnames))\n\n\n\nWarum sollte man den folgenden Code durch eine Funktion ersetzen?\n\nstatistiken &lt;- \n  tibble(\n    Statistik = c(\"Mittel\", \"Median\", \"Standardabweichung\"),\n    \"Institut 1\" = c(\n      mean(ergebnisse$`Institut 1`),\n      median(ergebnisse$`Institut 1`),\n      sd(ergebnisse$`Institut 1`)\n    ),\n    \"Institut 2\" = c(\n      mean(ergebnisse$`Institut 2`),\n      median(ergebnisse$`Institut 2`),\n      sd(ergebnisse$`Institut 2`)\n    ),\n    \"Institut 3\" = c(\n      mean(ergebnisse$`Institut 3`),\n      median(ergebnisse$`Institut 3`),\n      sd(ergebnisse$`Institut 3`)\n    )\n  )\n\n\n\nNutze den folgenden Codeschnipsel, um eine Funktion zu schreiben, die für einen Vektor die Statistiken berechnet, und eine andere Funktion, die daraus den obigen Tibble erstellt:\n\nberechne_statistiken &lt;-\n  function(institut) {\n    statistiken &lt;- \n      c(...,\n        ...,\n        ...)\n\n    return(statistiken)\n  }\n\nerstelle_stats_tibble &lt;-\n  function(ergebnisse) {\n    tibble(Statistik = c(...),\n           values =\n             ergebnisse %&gt;% \n             map(...) %&gt;% \n             bind_rows()) %&gt;% \n      unnest(...)\n  }\n\n\nLösungberechne_statistiken &lt;-\n  function(institut) {\n    statistiken &lt;- \n      c(mean(institut),\n        median(institut),\n        sd(institut))\n\n    return(statistiken)\n  }\n\nerstelle_stats_tibble &lt;-\n  function(ergebnisse) {\n    tibble(Statistik = c(\"Mittel\", \"Median\", \"Standardabweichung\"),\n           values =\n             ergebnisse %&gt;% \n             map(berechne_statistiken) %&gt;% \n             bind_rows()) %&gt;% \n      unnest(values)\n  }"
  },
  {
    "objectID": "index.html#vorstellung-der-ag",
    "href": "index.html#vorstellung-der-ag",
    "title": "Willkommen!",
    "section": "Vorstellung der AG",
    "text": "Vorstellung der AG"
  },
  {
    "objectID": "05-visualisierung.html",
    "href": "05-visualisierung.html",
    "title": "Visualisierung mit Grafiken",
    "section": "",
    "text": "Um uns einen Überblick über die Daten zu verschaffen und einfacher Zusammenhänge zwischen Variablen zu erhalten, ist es oft sinnvoll, Diagramme zu erstellen. R bietet dafür zahlreiche Möglichkeiten, die sehr flexibel genutzt werden können.\nIn dieser Einheit werden wir mit dem Datensatz m111survey aus dem tigerstats-Paket die Grundlagen für eine solche Visualisierung erarbeiten. Dieser Datensatz ist das Ergebnis einer Umfrage unter 71 Studierenden des Georgetown College in Kentucky.\nZunächst laden wir diesen Datensatz in unsere Umgebung.\n\ninstall.packages(\"tigerstats\")\n\n\nlibrary(tigerstats)\n\nMithilfe von ?m111survey können wir uns ansehen, welche Bedeutung die Variablen haben. Man könnte zum Beispiel annehmen, dass Studenten mit niedrigerem Notendurchschnitt eher dazu neigen, schnell zu fahren. Veranschaulichen wir diesen Zusammenhang in einem Diagramm:\n\nm111survey %&gt;% \n  ggplot(aes(x = GPA, y = fastest)) +\n  geom_point()\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nDieses Diagramm ist ein sogenannter Scatterplot bzw. ein Streudiagramm. Der Aufbau eines solchen Diagramms in R ist wie folgt:\n\ndatensatz %&gt;% \n  # Legt den \"Rahmen\" und die Achsen fest\n  ggplot(aes(x = x-Achsen-Variable, y = y-Achsen-Variable)) +\n  geom_... + # Das sogenannte \"Layer\", z.B. Punkte, Linien, Formen, ...\n  ... # Man kann mehrere Layer übereinander legen.\n\nMan könnte denken, dass diese Annahme tatsächlich stimmt. Legen wir mal eine “Ausgleichsgerade” durch die Punkte:\n\nm111survey %&gt;% \n  ggplot(aes(x = GPA, y = fastest)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") # lm steht für \"Linear Model\"\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nDer graue Balken in diesem Diagramm beschreibt im Grunde die Unsicherheit in unserem Modell. Wir sehen, dass er so breit ist, dass die Enden sich jeweils überlappen. Daher können wir nicht darauf schließen, dass der Notenschnitt einen Einfluss auf die höchste je gefahrene Geschwindigkeit hat.\nWir können aber mehr aus den Daten holen. Schauen wir uns zum Beispiel an, wie Frauen im Vergleich zu Männern in der Umfrage antworten:\n\nm111survey %&gt;% \n  ggplot(aes(x = GPA, y = fastest, color = sex)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWir sehen: Frauen haben tendenziell langsamere Höchstgeschwindigkeiten als Männer, aber auch hier überlappen sich die Balken.\nEin weiterer wichtiger Diagrammtyp ist das Histogramm. Es gibt an, wie oft ein bestimmtes “Level” einer Variable in den Daten vorkommt, zum Beispiel wie folgt:\n\nm111survey %&gt;% \n  ggplot(aes(x = fastest)) +\n  geom_histogram(fill = \"burlywood\", color = \"black\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nÄhnliches kann durch das Layer geom_density() erreicht werden. Dieses gibt nicht die Anzahl, sondern die Verteilung der Geschwindigkeiten an.\n\nm111survey %&gt;% \n  ggplot(aes(x = fastest)) +\n  geom_density(fill = \"burlywood\")"
  }
]